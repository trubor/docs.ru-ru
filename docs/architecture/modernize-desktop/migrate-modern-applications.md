---
title: Миграция современных классических приложений
description: Все, что нужно знать о процессе миграции для современных классических приложений.
ms.date: 01/19/2021
ms.openlocfilehash: 726677f2478de00989ba748200de562cc30f734b
ms.sourcegitcommit: 040b745ac19e4a5d23df17422ab30e72839f5754
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/21/2021
ms.locfileid: "107809758"
---
# <a name="migrating-modern-desktop-applications"></a>Миграция современных классических приложений

В этой главе мы рассматриваем наиболее распространенные проблемы и трудности, возникающие при переносе существующего приложения с платформы .NET Framework в .NET.

Сложное классическое приложение работает не в изоляции и нуждается в определенном взаимодействии с подсистемами, которые могут находиться на локальном компьютере или на удаленном сервере. Возможно, потребуется некий тип базы данных для локального или удаленного подключения к хранилищу сохраняемости. С появлением интернет- и сервис-ориентированных архитектур приложение обычно подключается к некоторой службе, размещенной на удаленном сервере или в облаке. Для реализации некоторых функциональных возможностей может потребоваться доступ к файловой системе компьютера. Возможно, вы также используете часть функциональных возможностей, находящихся внутри COM-объекта за пределами приложения, что является типичным сценарием, например, при интеграции сборок Office в приложение.

Кроме того, существуют различия в поверхности интерфейса API, предоставляемой .NET Framework и .NET, а некоторые функции, доступные в .NET Framework, недоступны в .NET. Поэтому важно знать и учитывать их при планировании миграции.

## <a name="configuration-files"></a>Файлы конфигурации.

Файлы конфигурации позволяют хранить наборы свойств, которые считываются во время выполнения и влияют на поведение приложений, например на расположение базы данных или количество выполнений цикла. Преимуществом этой методики является то, что вы можете изменить некоторые аспекты работы приложения без повторного написания кода и повторной компиляции. Это удобно, когда, например, один и тот же код приложения выполняется и в среде разработки с определенным набором значений конфигурации, и в рабочей среде с другим набором значений.

### <a name="configuration-on-net-framework"></a>Конфигурация в .NET Framework

Если у вас есть рабочее классическое приложение .NET Framework, скорее всего, у вас есть и файл *app.config*, обращение к которому осуществляется с помощью класса <xref:System.Configuration.AppSettingsSection> из пространства имен `System.Configuration`.

В инфраструктуре .NET Framework существует иерархия файлов конфигурации, которые наследуют свойства родительских элементов. Вы можете найти файл *machine.config*, определяющий множество свойств и разделов конфигурации, которые можно использовать или переопределить в любом производном файле конфигурации.

### <a name="configuration-on-net"></a>Конфигурация в .NET

В среде .NET файл *machine.config* не существует. Несмотря на то, что вы можете продолжать использовать старое пространство имен <xref:System.Configuration>, рекомендуем перейти на современное пространство имен <xref:Microsoft.Extensions.Configuration>, предлагающее большое число улучшений.

API конфигурации поддерживает концепцию поставщика конфигурации, который определяет источник данных, используемый для загрузки конфигурации. Существуют различные виды встроенных поставщиков, например:

- объектов .NET в памяти;
- INI-файлы;
- файлы JSON;
- файлы XML.
- аргументов командной строки;
- Переменные среды
- зашифрованное пользовательское хранилище.

 Либо вы можете создать его самостоятельно.

Новая конфигурация позволяет использовать список пар "имя-значение", которые можно сгруппировать в многоуровневую иерархию. Каждое хранимое значение сопоставляется со строкой, и имеется встроенная поддержка привязки, позволяющая десериализировать параметры в настраиваемый объект POCO.

Объект <xref:Microsoft.Extensions.Configuration.ConfigurationBuilder> позволяет добавить столько поставщиков конфигурации, сколько может потребоваться для приложения, используя правило приоритета для разрешения предпочтений. Таким образом, последний добавленный в код поставщик переопределяет все остальные. Это отличная функция для управления различными средами для выполнения, так как вы можете определить различные конфигурации для среды разработки, тестовой среды и рабочей среды, а также управлять ими с помощью одной функции в коде.

### <a name="migrating-configuration-files"></a>Перенос файлов конфигурации

Вы можете продолжить использовать существующий XML-файл app.config. Однако вы можете воспользоваться этой возможностью для переноса конфигурации, чтобы извлечь выгоду из некоторых усовершенствований, внесенных в .NET.

Чтобы перейти с несовременного файла *app.config* на новый файл конфигурации, необходимо сделать выбор между форматом XML и форматом JSON.

Если выбрать XML, преобразование будет простым. Так как содержимое файлов совпадает, просто сохраните файл *app.config* с типом XML. Затем измените код, ссылающийся на AppSettings, для использования класса `ConfigurationBuilder`. Это изменение не должно вызвать трудности.

Если вы хотите использовать формат JSON,но не желаете выполнять миграцию вручную, в .NET доступно средство [dotnet-config2json](https://www.nuget.org/packages/dotnet-config2json/), позволяющее преобразовать файл *app.config* в файл конфигурации JSON.

Кроме того, при использовании разделов конфигурации, определенных в файле *machine.config*, могут возникнуть некоторые проблемы. Например, рассмотрим следующую конфигурацию:

```xml
<configuration>
    <system.diagnostics>
        <switches>
            <add name="General" value="4" />
        </switches>
        <trace autoflush="true" indentsize="2">
            <listeners>
                <add name="myListener"
                     type="System.Diagnostics.TextWriterTraceListener,
                           System, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                     initializeData="MyListener.log"
                     traceOutputOptions="ProcessId, LogicalOperationStack, Timestamp, ThreadId, Callstack, DateTime" />
            </listeners>
        </trace>
    </system.diagnostics>
</configuration>
```

Если вы воспользуетесь этой конфигурацией в .NET, возникнет исключение:

> Нераспознанный раздел конфигурации System.Diagnostics

Это исключение возникает из-за того, что этот раздел и сборка, отвечающая за его обработку, были определены в файле *machine.config*, который теперь не существует.

Чтобы легко устранить проблему, можно скопировать определение раздела из старого файла конфигурации *machine.config* в новый:

```xml
<configSections>
    <section name="system.diagnostics"
             type="System.Diagnostics.SystemDiagnosticsSection,
                   System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>
</configSections>
```

## <a name="accessing-databases"></a>Доступ к базам данных

Практически всем классическим приложениям требуется тот или иной тип базы данных. В настольных системах часто можно встретить архитектуру клиент-сервер с прямым подключением между классическим приложением и ядром СУБД. Эти базы данных могут быть локальными или удаленными в зависимости от потребности в обмене информацией между разными пользователями.

С точки зрения кода существовало множество технологий и платформ, позволяющих разработчикам подключаться к базам данных, обновлять их и направлять в них запросы.

Если говорить о классическом приложении Windows, наиболее типичными примерами баз данных являются Microsoft Access и Microsoft SQL Server. При наличии более 20 лет опыта программирования для настольных систем вы наверняка будет знакомы с такими названиями, как ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ и Entity Framework.

### <a name="odbc"></a>ODBC

Вы можете продолжать использовать ODBC в .NET, так как корпорация Майкрософт предоставляет библиотеку `System.Data.Odbc`, совместимую с .NET Standard 2.0.

### <a name="ole-db"></a>OLE DB

Решение [OLE DB](/previous-versions/windows/desktop/ms722784(v=vs.85)) было отличным средством для обеспечения единообразного доступа к различным источникам данных. Однако оно было основано на модели COM, которая доступна только для Windows, и поэтому не вполне подходило для кроссплатформенной технологии, такой как .NET. Кроме того, оно не поддерживается в SQL Server 2014 и более поздних версий. По этим причинам OLE DB не будет поддерживаться технологией .NET.

### <a name="adonet"></a>ADO.NET

Вы по-прежнему можете использовать ADO.NET из существующего кода классических приложений в .NET. Для этого достаточно обновить некоторые пакеты NuGet.

### <a name="ef-core-vs-ef6"></a>EF Core и EF6

В настоящее время поддерживаются две версии Entity Framework (EF) — Entity Framework 6 (EF6) и EF Core.

Самой новой технологией, выпущенной в рамках платформы .NET Framework, является Entity Framework с актуальной версией 6.4. При запуске .NET Core корпорация Майкрософт также выпустила новый стек доступа к данным на основе Entity Framework, который называется Entity Framework Core.

EF 6.4 и EF Core можно использовать как в .NET Framework, так и в .NET. Итак, какие факторы влияют на выбор одного из этих двух решений?

EF 6.3 — это первая версия EF6, которая может запускаться в .NET и работать на разных платформах. На самом деле главной целью этого выпуска было упростить миграцию существующих приложений, использующих EF6, в .NET.

EF Core был разработан как аналог EF6. Большая часть API верхнего уровня сохранена, поэтому EF Core покажется знакомым тем разработчикам, которые использовали EF6.

Несмотря на совместимость, существуют различия в реализации, которые следует уточнить перед принятием решения.
Дополнительные сведения см. в разделе [Сравнение EF Core и EF6](/ef/efcore-and-ef6/).

Рекомендуется использовать EF Core в следующем случае:

* Приложению нужны возможности .NET.
* EF Core поддерживает все функции, которые требуются приложению.

Используйте EF6, если выполнены оба условия:

* Приложение будет работать на Windows и .NET Framework 4.0 или более поздней версии.
* EF6 поддерживает все функции, которые требуются приложению.

### <a name="relational-databases"></a>реляционные базы данных

#### <a name="sql-server"></a>SQL Server

Несколько лет назад одной из наилучших баз данных при разработке классических приложений было решение SQL Server. Используя <xref:System.Data.SqlClient> на платформе .NET Framework, вы могли получить доступ к версиям SQL Server, что инкапсулирует протоколы, относящиеся к базе данных.

В .NET доступен новый класс `SqlClient`, который полностью совместим с классом на платформе .NET Framework, но расположенным в библиотеке <xref:Microsoft.Data.SqlClient>. Чтобы все заработало должным образом, достаточно просто добавить ссылку на пакет NuGet [Microsoft.Data.SqlClient](https://www.nuget.org/packages/Microsoft.Data.SqlClient/) и выполнить переименование для пространств имен.

#### <a name="microsoft-access"></a>Microsoft Access

В течение многих лет Microsoft Access использовался там, где не было потребности в сложном и масштабируемом решении SQL Server. Вы по-прежнему можете подключиться к Microsoft Access с помощью библиотеки <xref:System.Data.Odbc>.

## <a name="consuming-services"></a>Использование служб

С появлением сервис-ориентированных архитектур классические приложения начали переходить от модели "клиент-сервер" к трехуровневому подходу. При подходе клиент-сервер прямое подключение к базе данных устанавливается из клиента, содержащего бизнес-логику, как правило, внутри одного файла EXE. С другой стороны, трехуровневый подход устанавливает промежуточный уровень служб, реализующий бизнес-логику и доступ к базе данных, что обеспечивает повышенную безопасность, масштабируемость и возможность повторного использования. Вместо работы с наборами данных напрямую подход на основе уровней использует набор служб, реализующих контракты и типы объектов, для обеспечения обмена данными.

Если у вас есть классическое приложение, использующее службу WCF, и вы хотите перенести его в .NET, необходимо учесть некоторые аспекты.

В первую очередь — как именно разрешить доступ конфигурации к службе. Так как конфигурация в .NET отличается, потребуется внести в файл конфигурации некоторые изменения.

Во-вторых, потребуется повторно создать клиент службы с использованием новых средств, доступных в Visual Studio 2019. На этом шаге необходимо рассмотреть активацию создания синхронных операций, чтобы обеспечить совместимость клиента с существующим кодом.

Если после миграции выяснится, что в .NET отсутствуют необходимые вам библиотеки, можете добавить ссылку на пакет NuGet [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility) и проверить наличие в нем недостающих функций.

Если вы используете класс <xref:System.Net.WebRequest> для выполнения вызовов веб-служб, то можете столкнуться с некоторыми отличиями .NET. Рекомендуется использовать вместо этого System.Net.Http.HttpClient.

## <a name="consuming-a-com-object"></a>Использование COM-объекта

В настоящее время не существует способа добавить ссылку на COM-объект из Visual Studio 2019 для использования с .NET. Поэтому необходимо изменить файл проекта вручную.

Вставьте структуру `COMReference` в файл проекта, как показано в следующем примере:

```xml
<ItemGroup>
    <COMReference Include="MSHTML">
        <Guid>{3050F1C5-98B5-11CF-BB82-00AA00BDCE0B}\</Guid>
        <VersionMajor>4</VersionMajor>
        <VersionMinor>0</VersionMinor>
        <Lcid>0</Lcid>
        <WrapperTool>primary</WrapperTool>
        <Isolated>false</Isolated>
    </COMReference>
</ItemGroup>
```

## <a name="more-things-to-consider"></a>Другие важные факторы

Некоторые технологии для библиотек .NET Framework недоступны для использования с .NET Core или .NET 5. Если подобные технологии применяются в вашем коде, рассмотрите альтернативные подходы, описанные в этом разделе.

[Пакет обеспечения совместимости Windows](../../core/porting/windows-compat-pack.md) предоставляет доступ к интерфейсам API, которые ранее были доступны только для .NET Framework. Его можно использовать в проектах .NET Core и .NET Standard.

Дополнительные сведения о совместимости API можно найти в документации по критическим изменениям и устаревшим/неиспользуемым API по адресу <https://docs.microsoft.com/dotnet/core/compatibility/fx-core>.

### <a name="appdomains"></a>Домены приложений

Домены приложений позволяют изолировать приложения друг от друга. Для этих доменов требуется поддержка среды выполнения, при этом они требовательны к ресурсам. Создание дополнительных доменов приложений не поддерживается. Вместо нее для изоляции кода мы рекомендуем использовать отдельные процессы или контейнеры. Для динамической загрузки сборок рекомендуется использовать новый класс <xref:System.Runtime.Loader.AssemblyLoadContext>.

Чтобы упростить перенос кода из .NET Framework, в .NET предоставляются некоторые поверхности API `AppDomain`. Некоторые API-интерфейсы работают без изменений (например, <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>), одни элементы не выполняют никаких действий (например, <xref:System.AppDomain.SetCachePath%2A>), а другие создают исключение <xref:System.PlatformNotSupportedException> (например, <xref:System.AppDomain.CreateDomain%2A>).

### <a name="remoting"></a>Удаленное взаимодействие

Удаленное взаимодействие .NET используется для взаимодействия доменов приложений, которое больше не поддерживается. Кроме того, для удаленного взаимодействия требуется поддержка среды выполнения, обслуживание которой дорого обходится. По этим причинам удаленное взаимодействие .NET не поддерживается в .NET.

Для взаимодействия между процессами вместо удаленного взаимодействия следует применять механизмы межпроцессного взаимодействия (IPC), например пространство имен <xref:System.IO.Pipes?displayProperty=nameWithType> или класс <xref:System.IO.MemoryMappedFiles.MemoryMappedFile>.

Для взаимодействия между компьютерами в качестве альтернативы можно использовать сетевое решение, желательно протокол на основе обычного текста с низкими издержками, например HTTP. Еще один вариант — веб-сервер Kestrel, используемый платформой ASP.NET Core.

### <a name="code-access-security-cas"></a>CAS (Code Access Security — безопасность доступа кода)

Песочница ограничивает ресурсы, используемые или выполняемые управляемыми приложениями или библиотеками, на основе среды выполнения или платформы. Она не поддерживается в .NET.

Чтобы свести к минимуму требуемый набор прав, применяйте ограничения безопасности, предусмотренные в операционной системе, например виртуализацию, контейнеры или учетные записи пользователей.

### <a name="security-transparency"></a>Прозрачность безопасности

Аналогично CAS, прозрачность безопасности позволяет декларативно отделить изолированный код от кода, критически важного с точки зрения безопасности, но больше не поддерживается как ограничение безопасности.

Чтобы свести к минимуму требуемый набор прав, применяйте ограничения безопасности, предусмотренные в операционной системе, например виртуализацию, контейнеры или учетные записи пользователей.

>[!div class="step-by-step"]
>[Назад](whats-new-dotnet.md )
>[Вперед](windows-migration.md)
