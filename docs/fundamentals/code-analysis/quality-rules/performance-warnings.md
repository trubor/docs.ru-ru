---
title: Правила производительности (анализ кода)
description: Сведения о правилах производительности для анализа кода.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 04177030afcae3a3081eb98592dd273f81021cef
ms.sourcegitcommit: 02cc87f02c46e603ea5925de95af746b7ab46a35
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/25/2021
ms.locfileid: "107954905"
---
# <a name="performance-rules"></a>Правила производительности

Правила производительности поддерживают высокоэффективные библиотеки и приложения.

## <a name="in-this-section"></a>Содержание раздела

| Правило | Описание |
| - | - |
| [CA1802. По возможности используйте литералы](ca1802.md) | Поле объявляется статичным и доступным только для чтения (Shared и ReadOnly в Visual Basic) и инициализируется со значением, вычисляемым во время компиляции. Поскольку значение, присвоенное конечному полю, вычисляется во время компиляции, замените объявление полем const (Const в Visual Basic), чтобы значение вычислялось не во время выполнения, а во время компиляции. |
| [CA1805: не делайте лишних инициализаций](ca1805.md) | Среда выполнения .NET инициализирует все поля ссылочных типов со значениями по умолчанию перед выполнением конструктора. В большинстве случаев явная инициализация поля со значением по умолчанию является избыточной, что увеличивает затраты на обслуживание и может привести к снижению производительности (например, при увеличении размера сборки). |
| [CA1806. Не игнорируйте результаты метода](ca1806.md) | Создается, но никогда не используется новый объект, либо вызывается метод, который создает и возвращает новую строку, и такая новая строка никогда не используется, либо метод COM или P/Invoke возвращает HRESULT или код ошибки, который никогда не используется. |
| [CA1810. Инициализируйте статические поля ссылочных типов при объявлении](ca1810.md) | Если в типе объявляется явный статический конструктор, компилятор JIT добавляет проверку в каждый статический метод и конструктор экземпляров этого типа, чтобы убедиться, что статический конструктор уже вызывался ранее. Проверки статических конструкторов могут привести к снижению производительности. |
| [CA1812. Избегайте неиспользуемых внутренних классов](ca1812.md) | Экземпляр типа уровня сборки не создается кодом в сборке. |
| [CA1813. Избегайте незапечатанных атрибутов](ca1813.md) | .NET предоставляет методы для извлечения настраиваемых атрибутов. По умолчанию эти методы осуществляют поиск иерархии наследования атрибутов. Если запечатать атрибут, поиск в иерархии наследования выполняться не будет, в результате чего может повыситься производительность. |
| [CA1814. Используйте массивы массивов вместо многомерных массивов](ca1814.md) | Массив массивов — это массив, элементы которого сами являются массивами. Массивы, которые составляют элементы, могут иметь различные размеры, что позволяет экономить пространство для некоторых наборов данных. |
| [CA1815. Переопределяйте операторы Equals и равенства для типов значений](ca1815.md) | В унаследованной реализации Equals для типов значений используется библиотека отражения и сравнивается содержимое всех полей. Отражение является процессом, требующим с точки зрения вычислений больших затрат, и сравнение каждого поля на равенство может быть лишним. Если предполагается, что пользователи будут сравнивать, сортировать экземпляры или использовать их в качестве ключей хэш-таблиц, тип значения должен реализовывать Equals. |
| [CA1819. Свойства не должны возвращать массивы](ca1819.md) | Массивы, возвращаемые свойствами, не защищены от записи, даже если свойство доступно только для чтения. Чтобы защитить массив от изменений, свойство должно возвращать копию массива. Как правило, пользователи не понимают требований к производительности при вызове такого свойства. |
| [CA1820. Проверяйте наличие пустых строк, используя длину строки](ca1820.md) | Сравнивать строки с использованием свойства String.Length или метода String.IsNullOrEmpty значительно быстрее, чем с помощью Equals. |
| [CA1821. Удалите пустые методы завершения](ca1821.md) | Если возможно, старайтесь не использовать финализаторы, поскольку из-за отслеживания жизненного срока объектов снижается производительность программы. Пустой метод завершения приводит к дополнительной нагрузке без каких бы то ни было преимуществ. |
| [CA1822. Пометьте члены как статические](ca1822.md) | Элементы, не обращающиеся к данным экземпляра и не вызывающие методы экземпляра, можно помечать как статические (общие в Visual Basic). Если пометить методы как статические, компилятор предоставит этим членам невиртуальные места вызова. Это обеспечивает значительное повышение производительности при работе с кодом, для которого важна высокая производительность системы. |
| [CA1823. Избегайте неиспользуемых частных полей](ca1823.md) | Обнаружены закрытые поля, доступ к которым, судя по всему, не предоставляется в сборке. |
| [CA1824. Помечайте сборки с помощью NeutralResourcesLanguageAttribute](ca1824.md) | Атрибут NeutralResourcesLanguage сообщает Resource Manager о языке, используемом для отображения независящих от языка и региональных параметров ресурсов для сборки. При этом повышается эффективность поиска первого загружаемого ресурса и может сократиться рабочее множество. |
| [CA1825: Избегайте выделения массивов нулевой длины](ca1825.md) | Инициализация массива нулевой длины приводит к выделению лишней памяти. Вместо этого используйте статический выделенный экземпляр пустого массива, вызвав метод <xref:System.Array.Empty%2A?displayProperty=nameWithType>. Выделение памяти является общим для всех вызовов этого метода. |
| [CA1826: Используйте свойство вместо метода Enumerable в LINQ](ca1826.md) | Метод LINQ <xref:System.Linq.Enumerable> использовался для типа, поддерживающего эквивалентное и более эффективное свойство. |
| [CA1827: Не используйте Count/LongCount, если можно использовать Any](ca1827.md) | Использовался метод <xref:System.Linq.Enumerable.Count%2A> или <xref:System.Linq.Enumerable.LongCount%2A>, тогда как более эффективным был бы метод <xref:System.Linq.Enumerable.Any%2A>. |
| [CA1828: Не используйте CountAsync/LongCountAsync, если можно использовать AnyAsync](ca1828.md) | Использовался метод <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> или <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A>, тогда как более эффективным был бы метод <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A>. |
| [CA1829: Используйте свойство Length/Count вместо метода Enumerable.Count](ca1829.md) | Метод LINQ <xref:System.Linq.Enumerable.Count%2A> использовался для типа, поддерживающего эквивалентное и более эффективное свойство `Length` или `Count`. |
| [CA1830: предпочитать строго типизированные перегрузки методов Append и Insert в StringBuilder](ca1830.md) | Методы <xref:System.Text.StringBuilder.Append%2A> и <xref:System.Text.StringBuilder.Insert%2A> предоставляют перегрузки для нескольких типов, помимо System.String.  По возможности рекомендуется использовать строго типизированные перегрузки вместо использования ToString() и перегрузки на основе строк. |
| [CA1831: при необходимости используйте AsSpan вместо индексаторов на основе диапазона для строки](ca1831.md) | При использовании в строке индексатора диапазона и неявного присваивания значения типу ReadOnlySpan&lt;char&gt; метод <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, который создает копию запрошенной части строки. |
| [CA1832: используйте AsSpan или AsMemory вместо индексаторов на основе диапазона для получения части массива ReadOnlySpan или ReadOnlyMemory](ca1832.md) | При использовании в массиве индексатора диапазона и неявного присваивания значения типу <xref:System.ReadOnlySpan%601> или <xref:System.ReadOnlyMemory%601> метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, который создает копию запрошенной части массива. |
| [CA1833: используйте AsSpan или AsMemory вместо индексаторов на основе диапазона для получения части массива Span или Memory](ca1833.md) | При использовании в массиве индексатора диапазона и неявного присваивания значения типу <xref:System.Span%601> или <xref:System.Memory%601> метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, который создает копию запрошенной части массива. |
| [CA1834: используйте StringBuilder.Append(char) для строк с одним символом.](ca1834.md) | <xref:System.Text.StringBuilder> имеет перегрузку `Append`, которая принимает `char` в качестве аргумента. Лучше вызывать перегрузку `char` для повышения производительности. |
| [CA1835: выбирайте перегрузки на базе Memory для ReadAsync и WriteAsync](ca1835.md) | Stream имеет перегрузку ReadAsync, которая принимает Memory&lt;Byte&gt; в качестве первого аргумента, и перегрузку WriteAsync, принимающую ReadOnlyMemory&lt;Byte&gt; в качестве первого аргумента. Следует вызывать перегрузки на основе памяти, которые являются более эффективными. |
| [CA1836: используйте `IsEmpty` вместо `Count` по возможности](ca1836.md) | Используйте свойство `IsEmpty`, которое более эффективно, чем `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> или <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>, чтобы определить, содержит ли объект какие-либо элементы. |
| [CA1837: используйте `Environment.ProcessId` вместо `Process.GetCurrentProcess().Id`](ca1837.md) | `Environment.ProcessId` проще и быстрее, чем `Process.GetCurrentProcess().Id`. |
| [CA1838: не используйте параметры `StringBuilder` для вызовов P/Invoke](ca1838.md) | При маршалировании `StringBuilder` всегда создается собственная копия буфера, что приводит к множественным выделениям для одной операции маршалирования. |
| [CA1841: предпочитайте словари, содержащие методы](ca1841.md) | Вызов `Contains` в `Keys` или в коллекции `Values` может быть более затратным, чем вызов `ContainsKey` или `ContainsValue` в самом словаре. |
