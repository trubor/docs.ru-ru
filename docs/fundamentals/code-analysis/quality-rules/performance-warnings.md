---
title: Правила производительности (анализ кода)
description: Сведения о правилах производительности для анализа кода.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 04177030afcae3a3081eb98592dd273f81021cef
ms.sourcegitcommit: 02cc87f02c46e603ea5925de95af746b7ab46a35
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/25/2021
ms.locfileid: "107954905"
---
# <a name="performance-rules"></a><span data-ttu-id="2ba24-103">Правила производительности</span><span class="sxs-lookup"><span data-stu-id="2ba24-103">Performance rules</span></span>

<span data-ttu-id="2ba24-104">Правила производительности поддерживают высокоэффективные библиотеки и приложения.</span><span class="sxs-lookup"><span data-stu-id="2ba24-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="2ba24-105">Содержание раздела</span><span class="sxs-lookup"><span data-stu-id="2ba24-105">In this section</span></span>

| <span data-ttu-id="2ba24-106">Правило</span><span class="sxs-lookup"><span data-stu-id="2ba24-106">Rule</span></span> | <span data-ttu-id="2ba24-107">Описание</span><span class="sxs-lookup"><span data-stu-id="2ba24-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="2ba24-108">CA1802. По возможности используйте литералы</span><span class="sxs-lookup"><span data-stu-id="2ba24-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="2ba24-109">Поле объявляется статичным и доступным только для чтения (Shared и ReadOnly в Visual Basic) и инициализируется со значением, вычисляемым во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="2ba24-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="2ba24-110">Поскольку значение, присвоенное конечному полю, вычисляется во время компиляции, замените объявление полем const (Const в Visual Basic), чтобы значение вычислялось не во время выполнения, а во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="2ba24-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="2ba24-111">CA1805: не делайте лишних инициализаций</span><span class="sxs-lookup"><span data-stu-id="2ba24-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="2ba24-112">Среда выполнения .NET инициализирует все поля ссылочных типов со значениями по умолчанию перед выполнением конструктора.</span><span class="sxs-lookup"><span data-stu-id="2ba24-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="2ba24-113">В большинстве случаев явная инициализация поля со значением по умолчанию является избыточной, что увеличивает затраты на обслуживание и может привести к снижению производительности (например, при увеличении размера сборки).</span><span class="sxs-lookup"><span data-stu-id="2ba24-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="2ba24-114">CA1806. Не игнорируйте результаты метода</span><span class="sxs-lookup"><span data-stu-id="2ba24-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="2ba24-115">Создается, но никогда не используется новый объект, либо вызывается метод, который создает и возвращает новую строку, и такая новая строка никогда не используется, либо метод COM или P/Invoke возвращает HRESULT или код ошибки, который никогда не используется.</span><span class="sxs-lookup"><span data-stu-id="2ba24-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="2ba24-116">CA1810. Инициализируйте статические поля ссылочных типов при объявлении</span><span class="sxs-lookup"><span data-stu-id="2ba24-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="2ba24-117">Если в типе объявляется явный статический конструктор, компилятор JIT добавляет проверку в каждый статический метод и конструктор экземпляров этого типа, чтобы убедиться, что статический конструктор уже вызывался ранее.</span><span class="sxs-lookup"><span data-stu-id="2ba24-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="2ba24-118">Проверки статических конструкторов могут привести к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="2ba24-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="2ba24-119">CA1812. Избегайте неиспользуемых внутренних классов</span><span class="sxs-lookup"><span data-stu-id="2ba24-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="2ba24-120">Экземпляр типа уровня сборки не создается кодом в сборке.</span><span class="sxs-lookup"><span data-stu-id="2ba24-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="2ba24-121">CA1813. Избегайте незапечатанных атрибутов</span><span class="sxs-lookup"><span data-stu-id="2ba24-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="2ba24-122">.NET предоставляет методы для извлечения настраиваемых атрибутов.</span><span class="sxs-lookup"><span data-stu-id="2ba24-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="2ba24-123">По умолчанию эти методы осуществляют поиск иерархии наследования атрибутов.</span><span class="sxs-lookup"><span data-stu-id="2ba24-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="2ba24-124">Если запечатать атрибут, поиск в иерархии наследования выполняться не будет, в результате чего может повыситься производительность.</span><span class="sxs-lookup"><span data-stu-id="2ba24-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="2ba24-125">CA1814. Используйте массивы массивов вместо многомерных массивов</span><span class="sxs-lookup"><span data-stu-id="2ba24-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="2ba24-126">Массив массивов — это массив, элементы которого сами являются массивами.</span><span class="sxs-lookup"><span data-stu-id="2ba24-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="2ba24-127">Массивы, которые составляют элементы, могут иметь различные размеры, что позволяет экономить пространство для некоторых наборов данных.</span><span class="sxs-lookup"><span data-stu-id="2ba24-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="2ba24-128">CA1815. Переопределяйте операторы Equals и равенства для типов значений</span><span class="sxs-lookup"><span data-stu-id="2ba24-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="2ba24-129">В унаследованной реализации Equals для типов значений используется библиотека отражения и сравнивается содержимое всех полей.</span><span class="sxs-lookup"><span data-stu-id="2ba24-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="2ba24-130">Отражение является процессом, требующим с точки зрения вычислений больших затрат, и сравнение каждого поля на равенство может быть лишним.</span><span class="sxs-lookup"><span data-stu-id="2ba24-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="2ba24-131">Если предполагается, что пользователи будут сравнивать, сортировать экземпляры или использовать их в качестве ключей хэш-таблиц, тип значения должен реализовывать Equals.</span><span class="sxs-lookup"><span data-stu-id="2ba24-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="2ba24-132">CA1819. Свойства не должны возвращать массивы</span><span class="sxs-lookup"><span data-stu-id="2ba24-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="2ba24-133">Массивы, возвращаемые свойствами, не защищены от записи, даже если свойство доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2ba24-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="2ba24-134">Чтобы защитить массив от изменений, свойство должно возвращать копию массива.</span><span class="sxs-lookup"><span data-stu-id="2ba24-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="2ba24-135">Как правило, пользователи не понимают требований к производительности при вызове такого свойства.</span><span class="sxs-lookup"><span data-stu-id="2ba24-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="2ba24-136">CA1820. Проверяйте наличие пустых строк, используя длину строки</span><span class="sxs-lookup"><span data-stu-id="2ba24-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="2ba24-137">Сравнивать строки с использованием свойства String.Length или метода String.IsNullOrEmpty значительно быстрее, чем с помощью Equals.</span><span class="sxs-lookup"><span data-stu-id="2ba24-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="2ba24-138">CA1821. Удалите пустые методы завершения</span><span class="sxs-lookup"><span data-stu-id="2ba24-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="2ba24-139">Если возможно, старайтесь не использовать финализаторы, поскольку из-за отслеживания жизненного срока объектов снижается производительность программы.</span><span class="sxs-lookup"><span data-stu-id="2ba24-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="2ba24-140">Пустой метод завершения приводит к дополнительной нагрузке без каких бы то ни было преимуществ.</span><span class="sxs-lookup"><span data-stu-id="2ba24-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="2ba24-141">CA1822. Пометьте члены как статические</span><span class="sxs-lookup"><span data-stu-id="2ba24-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="2ba24-142">Элементы, не обращающиеся к данным экземпляра и не вызывающие методы экземпляра, можно помечать как статические (общие в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2ba24-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="2ba24-143">Если пометить методы как статические, компилятор предоставит этим членам невиртуальные места вызова.</span><span class="sxs-lookup"><span data-stu-id="2ba24-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="2ba24-144">Это обеспечивает значительное повышение производительности при работе с кодом, для которого важна высокая производительность системы.</span><span class="sxs-lookup"><span data-stu-id="2ba24-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="2ba24-145">CA1823. Избегайте неиспользуемых частных полей</span><span class="sxs-lookup"><span data-stu-id="2ba24-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="2ba24-146">Обнаружены закрытые поля, доступ к которым, судя по всему, не предоставляется в сборке.</span><span class="sxs-lookup"><span data-stu-id="2ba24-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="2ba24-147">CA1824. Помечайте сборки с помощью NeutralResourcesLanguageAttribute</span><span class="sxs-lookup"><span data-stu-id="2ba24-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="2ba24-148">Атрибут NeutralResourcesLanguage сообщает Resource Manager о языке, используемом для отображения независящих от языка и региональных параметров ресурсов для сборки.</span><span class="sxs-lookup"><span data-stu-id="2ba24-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="2ba24-149">При этом повышается эффективность поиска первого загружаемого ресурса и может сократиться рабочее множество.</span><span class="sxs-lookup"><span data-stu-id="2ba24-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="2ba24-150">CA1825: Избегайте выделения массивов нулевой длины</span><span class="sxs-lookup"><span data-stu-id="2ba24-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="2ba24-151">Инициализация массива нулевой длины приводит к выделению лишней памяти.</span><span class="sxs-lookup"><span data-stu-id="2ba24-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="2ba24-152">Вместо этого используйте статический выделенный экземпляр пустого массива, вызвав метод <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2ba24-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2ba24-153">Выделение памяти является общим для всех вызовов этого метода.</span><span class="sxs-lookup"><span data-stu-id="2ba24-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="2ba24-154">CA1826: Используйте свойство вместо метода Enumerable в LINQ</span><span class="sxs-lookup"><span data-stu-id="2ba24-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="2ba24-155">Метод LINQ <xref:System.Linq.Enumerable> использовался для типа, поддерживающего эквивалентное и более эффективное свойство.</span><span class="sxs-lookup"><span data-stu-id="2ba24-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="2ba24-156">CA1827: Не используйте Count/LongCount, если можно использовать Any</span><span class="sxs-lookup"><span data-stu-id="2ba24-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="2ba24-157">Использовался метод <xref:System.Linq.Enumerable.Count%2A> или <xref:System.Linq.Enumerable.LongCount%2A>, тогда как более эффективным был бы метод <xref:System.Linq.Enumerable.Any%2A>.</span><span class="sxs-lookup"><span data-stu-id="2ba24-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="2ba24-158">CA1828: Не используйте CountAsync/LongCountAsync, если можно использовать AnyAsync</span><span class="sxs-lookup"><span data-stu-id="2ba24-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="2ba24-159">Использовался метод <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> или <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A>, тогда как более эффективным был бы метод <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="2ba24-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="2ba24-160">CA1829: Используйте свойство Length/Count вместо метода Enumerable.Count</span><span class="sxs-lookup"><span data-stu-id="2ba24-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="2ba24-161">Метод LINQ <xref:System.Linq.Enumerable.Count%2A> использовался для типа, поддерживающего эквивалентное и более эффективное свойство `Length` или `Count`.</span><span class="sxs-lookup"><span data-stu-id="2ba24-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="2ba24-162">CA1830: предпочитать строго типизированные перегрузки методов Append и Insert в StringBuilder</span><span class="sxs-lookup"><span data-stu-id="2ba24-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="2ba24-163">Методы <xref:System.Text.StringBuilder.Append%2A> и <xref:System.Text.StringBuilder.Insert%2A> предоставляют перегрузки для нескольких типов, помимо System.String.</span><span class="sxs-lookup"><span data-stu-id="2ba24-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="2ba24-164">По возможности рекомендуется использовать строго типизированные перегрузки вместо использования ToString() и перегрузки на основе строк.</span><span class="sxs-lookup"><span data-stu-id="2ba24-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="2ba24-165">CA1831: при необходимости используйте AsSpan вместо индексаторов на основе диапазона для строки</span><span class="sxs-lookup"><span data-stu-id="2ba24-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="2ba24-166">При использовании в строке индексатора диапазона и неявного присваивания значения типу ReadOnlySpan&lt;char&gt; метод <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, который создает копию запрошенной части строки.</span><span class="sxs-lookup"><span data-stu-id="2ba24-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="2ba24-167">CA1832: используйте AsSpan или AsMemory вместо индексаторов на основе диапазона для получения части массива ReadOnlySpan или ReadOnlyMemory</span><span class="sxs-lookup"><span data-stu-id="2ba24-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="2ba24-168">При использовании в массиве индексатора диапазона и неявного присваивания значения типу <xref:System.ReadOnlySpan%601> или <xref:System.ReadOnlyMemory%601> метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, который создает копию запрошенной части массива.</span><span class="sxs-lookup"><span data-stu-id="2ba24-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="2ba24-169">CA1833: используйте AsSpan или AsMemory вместо индексаторов на основе диапазона для получения части массива Span или Memory</span><span class="sxs-lookup"><span data-stu-id="2ba24-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="2ba24-170">При использовании в массиве индексатора диапазона и неявного присваивания значения типу <xref:System.Span%601> или <xref:System.Memory%601> метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> будет использоваться вместо <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, который создает копию запрошенной части массива.</span><span class="sxs-lookup"><span data-stu-id="2ba24-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="2ba24-171">CA1834: используйте StringBuilder.Append(char) для строк с одним символом.</span><span class="sxs-lookup"><span data-stu-id="2ba24-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="2ba24-172"><xref:System.Text.StringBuilder> имеет перегрузку `Append`, которая принимает `char` в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="2ba24-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="2ba24-173">Лучше вызывать перегрузку `char` для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="2ba24-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="2ba24-174">CA1835: выбирайте перегрузки на базе Memory для ReadAsync и WriteAsync</span><span class="sxs-lookup"><span data-stu-id="2ba24-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="2ba24-175">Stream имеет перегрузку ReadAsync, которая принимает Memory&lt;Byte&gt; в качестве первого аргумента, и перегрузку WriteAsync, принимающую ReadOnlyMemory&lt;Byte&gt; в качестве первого аргумента.</span><span class="sxs-lookup"><span data-stu-id="2ba24-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="2ba24-176">Следует вызывать перегрузки на основе памяти, которые являются более эффективными.</span><span class="sxs-lookup"><span data-stu-id="2ba24-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="2ba24-177">CA1836: используйте `IsEmpty` вместо `Count` по возможности</span><span class="sxs-lookup"><span data-stu-id="2ba24-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="2ba24-178">Используйте свойство `IsEmpty`, которое более эффективно, чем `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> или <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>, чтобы определить, содержит ли объект какие-либо элементы.</span><span class="sxs-lookup"><span data-stu-id="2ba24-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="2ba24-179">CA1837: используйте `Environment.ProcessId` вместо `Process.GetCurrentProcess().Id`</span><span class="sxs-lookup"><span data-stu-id="2ba24-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="2ba24-180">`Environment.ProcessId` проще и быстрее, чем `Process.GetCurrentProcess().Id`.</span><span class="sxs-lookup"><span data-stu-id="2ba24-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="2ba24-181">CA1838: не используйте параметры `StringBuilder` для вызовов P/Invoke</span><span class="sxs-lookup"><span data-stu-id="2ba24-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="2ba24-182">При маршалировании `StringBuilder` всегда создается собственная копия буфера, что приводит к множественным выделениям для одной операции маршалирования.</span><span class="sxs-lookup"><span data-stu-id="2ba24-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
| [<span data-ttu-id="2ba24-183">CA1841: предпочитайте словари, содержащие методы</span><span class="sxs-lookup"><span data-stu-id="2ba24-183">CA1841: Prefer Dictionary Contains methods</span></span>](ca1841.md) | <span data-ttu-id="2ba24-184">Вызов `Contains` в `Keys` или в коллекции `Values` может быть более затратным, чем вызов `ContainsKey` или `ContainsValue` в самом словаре.</span><span class="sxs-lookup"><span data-stu-id="2ba24-184">Calling `Contains` on the `Keys` or `Values` collection may often be more expensive than calling `ContainsKey` or `ContainsValue` on the dictionary itself.</span></span> |
