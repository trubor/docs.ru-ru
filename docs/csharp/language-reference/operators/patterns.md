---
title: Шаблоны — справочник по C#
description: Сведения о шаблонах, поддерживаемых выражениями и операторами сопоставления шаблонов C# — справочник по C#
ms.date: 04/05/2021
f1_keywords:
- and_CSharpKeyword
- or_CSharpKeyword
- not_CSharpKeyword
helpviewer_keywords:
- pattern matching [C#]
- and keyword [C#]
- or keyword [C#]
- not keyword [C#]
ms.openlocfilehash: cb3517516b09e21483985b04977313617a3a26fe
ms.sourcegitcommit: 02cc87f02c46e603ea5925de95af746b7ab46a35
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/25/2021
ms.locfileid: "107954722"
---
# <a name="patterns-c-reference"></a>Шаблоны (справочник по C#)

Возможность использовать сопоставление шаблонов впервые появилась в C# 7.0. С тех пор в каждой новой основной версии C# возможности сопоставления шаблонов расширяются. Сопоставление шаблонов поддерживают следующие выражения и операторы C#:

- [Выражение `is`](is.md)
- [Оператор](../keywords/switch.md) `switch`
- [Выражение](switch-expression.md) `switch` (появилось в C# 8.0)

В этих конструкциях можно сравнить входное выражение с любым из следующих шаблонов:

- [Шаблон объявления](#declaration-and-type-patterns): для проверки типа выражения в среде выполнения и, в случае равенства, присвоения объявленной переменной результата этого выражения. Впервые появился в C# 7.0.
- [Шаблон типа](#declaration-and-type-patterns): для проверки типа выражения в среде выполнения. Впервые появился в C# 9.0.
- [Шаблон константы](#constant-pattern): для проверки того, равен ли результат выражения указанной константе. Впервые появился в C# 7.0.
- [Реляционные шаблоны](#relational-patterns): для сравнения результата выражения с заданной константой. Впервые появился в C# 9.0.
- [Логические шаблоны](#logical-patterns): для проверки того, соответствует ли выражение логической комбинации шаблонов. Впервые появился в C# 9.0.
- [Шаблон свойства](#property-pattern): для проверки того, соответствуют ли свойства или поля выражения вложенным шаблонам. Впервые появился в C# 8.0.
- [Позиционный шаблон](#positional-pattern): для деконструкции результата выражения и проверки того, соответствуют ли результирующие значения вложенным шаблонам. Впервые появился в C# 8.0.
- [Шаблон](#var-pattern) `var`: для сравнения любых выражений и присваивания результата сравнения объявленной переменной. Впервые появился в C# 7.0.
- [Шаблон пустой переменной](#discard-pattern): для сравнения любых выражений. Впервые появился в C# 8.0.

[Логические шаблоны](#logical-patterns), [шаблоны свойств](#property-pattern) и [позиционные шаблоны](#positional-pattern) являются *рекурсивными* шаблонами. То есть, они могут содержать *вложенные* шаблоны.

Пример использования этих шаблонов для создания управляемого данными алгоритма можно посмотреть в разделе [Учебник: использование сопоставления шаблонов для создания управляемых типами и управляемых данными алгоритмов](../../tutorials/pattern-matching.md).

## <a name="declaration-and-type-patterns"></a>Шаблоны объявления и шаблоны типов

Шаблоны объявления и шаблоны типов используются для проверки того, совместим ли с указанным типом тип определенного выражения в среде выполнения. С помощью шаблона объявления можно также объявить новую локальную переменную. Если шаблон объявления соответствует выражению, этой переменной присваивается результат преобразованного выражения, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/DeclarationAndTypePatterns.cs" id="BasicExample":::

Начиная с C# 7.0, *шаблон объявления* с типом `T` соответствует выражению в том случае, если результат выражения имеет значение, отличное от NULL, и выполняется любое из следующих условий:

- Тип результата выражения в среде выполнения — `T`.

- Тип результата выражения в среде выполнения является производным от типа `T` или реализует интерфейс `T` или существует другое [неявное преобразования ссылок](~/_csharplang/spec/conversions.md#implicit-reference-conversions) из него в `T`. В следующем примере показаны два случая, когда данное условие истинно:

  :::code language="csharp" source="snippets/patterns/DeclarationAndTypePatterns.cs" id="ReferenceConversion":::

  В предыдущем примере при первом вызове метода `GetSourceLabel` первый шаблон соответствует значению аргумента, так как тип этого аргумента (`int[]`) в среде выполнения является производным от типа <xref:System.Array>. При втором вызове метода `GetSourceLabel` тип аргумента в среде выполнения (<xref:System.Collections.Generic.List%601>) не является производным от типа <xref:System.Array>, но реализует интерфейс <xref:System.Collections.Generic.ICollection%601>.

- Тип результата выражения в среде выполнения является [типом, допускающим значение NULL](../builtin-types/nullable-value-types.md), и имеющим базовый тип `T`.

- Существует [упаковка-преобразование](../../programming-guide/types/boxing-and-unboxing.md#boxing) или [распаковка-преобразование](../../programming-guide/types/boxing-and-unboxing.md#unboxing) из типа результата выражения в среде выполнения в тип `T`.

В следующем примере показаны два последних условия:

:::code language="csharp" source="snippets/patterns/DeclarationAndTypePatterns.cs" id="NullableAndUnboxing":::

Если требуется проверить только тип выражения, можно вместо имени переменной использовать пустую переменную `_`, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/DeclarationAndTypePatterns.cs" id="DiscardVariable":::

Начиная с C# 9.0, для этой цели можно использовать *шаблон типа*, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/DeclarationAndTypePatterns.cs" id="TypePattern":::

Как и шаблон объявления, шаблон типа соответствует выражению, если результат выражения не равен NULL, а его тип в среде выполнения удовлетворяет любому из указанных выше условий.

Дополнительные сведения см. в разделах [Шаблон объявления](~/_csharplang/proposals/csharp-8.0/patterns.md#declaration-pattern) и [Шаблон типа](~/_csharplang/proposals/csharp-9.0/patterns3.md#type-patterns) в примечаниях к предлагаемой функции.

## <a name="constant-pattern"></a>Шаблон константы

Начиная с C# 7.0, вы можете использовать *шаблон константы* для проверки того, равен ли результат выражения заданной константе, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/ConstantPattern.cs" id="BasicExample":::

В шаблоне константы можно использовать любое константное выражение, например:

- [целочисленный](../builtin-types/integral-numeric-types.md) литерал или литерал [с плавающей точкой](../builtin-types/floating-point-numeric-types.md);
- [символьный](../builtin-types/char.md) или [строковый](../builtin-types/reference-types.md#the-string-type) литерал;
- логическое значение `true` или `false`;
- значение типа [enum](../builtin-types/enum.md);
- имя объявленного поля с модификатором [const](../keywords/const.md) или локального элемента.
- `null`

Используйте шаблон константы для проверки на `null`, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/ConstantPattern.cs" id="NullCheck":::

Компилятор гарантирует, что при вычислении выражения `x is null` не будет вызван перегруженный пользователем оператор равенства `==`.

Начиная с C# 9.0, вы можете использовать шаблон константы `null` с [отрицанием](#logical-patterns) для проверки неравенства значению NULL, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/ConstantPattern.cs" id="NonNullCheck":::

Дополнительные сведения см. в разделе [Шаблон константы](~/_csharplang/proposals/csharp-8.0/patterns.md#constant-pattern) в примечании к предлагаемой функции.

## <a name="relational-patterns"></a>Реляционные шаблоны

Начиная с C# 9.0, вы можете использовать *реляционный шаблон* для сравнения результата выражения с константой, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/RelationalPatterns.cs" id="BasicExample":::

В реляционном шаблоне можно использовать любые [операторы отношений](comparison-operators.md) — `<`, `>`, `<=`, `>=`. Правая часть реляционного шаблона должна быть константным выражением. Константное выражение может быть [целым числом](../builtin-types/integral-numeric-types.md), [числом с плавающей точкой](../builtin-types/floating-point-numeric-types.md), [символом](../builtin-types/char.md) или иметь тип [enum](../builtin-types/enum.md).

Чтобы проверить, находится ли результат выражения в определенном диапазоне, сопоставьте его с [шаблоном конъюнкции](#logical-patterns) (`and`), как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/RelationalPatterns.cs" id="WithCombinators":::

Если результат выражения — `null` или его не удается преобразовать в тип константы с помощью преобразования, допускающего значение NULL, или распаковки-преобразования, то реляционный шаблон не соответствует выражению.

Дополнительные сведения см. в разделе [Реляционные шаблоны](~/_csharplang/proposals/csharp-9.0/patterns3.md#relational-patterns) в примечании к предлагаемой функции.

## <a name="logical-patterns"></a>Логические шаблоны

Начиная с C# 9.0, вы можете использовать блоки объединения `not`, `and` и `or` для создания следующих *логических шаблонов*:

- *Шаблон отрицания* `not`, который соответствует выражению, если шаблон с отрицанием не соответствует выражению. В следующем примере показано, как можно инвертировать [шаблон константы](#constant-pattern) `null`, чтобы проверить, имеет ли выражение значение, отличное от NULL:

  :::code language="csharp" source="snippets/patterns/LogicalPatterns.cs" id="NotPattern":::

- *Шаблон конъюнкции* `and`, который соответствует выражению, если оба шаблона соответствуют этому выражению. В следующем примере показано, как можно объединить [реляционные шаблоны](#relational-patterns), чтобы проверить, находится ли значение в определенном диапазоне:

  :::code language="csharp" source="snippets/patterns/LogicalPatterns.cs" id="AndPattern":::

- *Шаблон дизъюнкции* `or`, который соответствует выражению, если любой из шаблонов соответствует данному выражению, как показано в следующем примере:

  :::code language="csharp" source="snippets/patterns/LogicalPatterns.cs" id="OrPattern":::

Как показано в предыдущем примере, блоки объединения в шаблоне можно использовать многократно.

Блок объединения шаблонов `and` имеет более высокий приоритет, чем `or`. Чтобы явно задать приоритет, используйте круглые скобки, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/LogicalPatterns.cs" id="WithParentheses":::

> [!NOTE]
> Порядок проверки шаблонов не определен. Во время выполнения можно сначала проверить правые вложенные шаблоны шаблонов `or` и `and`.

Дополнительные сведения см. в разделе [Блоки объединения шаблонов](~/_csharplang/proposals/csharp-9.0/patterns3.md#pattern-combinators) в примечании к предлагаемой функции.

## <a name="property-pattern"></a>Шаблон свойства

Начиная с C# 8.0, вы можете использовать *шаблон свойства* для сопоставления свойств или полей выражения с вложенными шаблонами, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/PropertyPattern.cs" id="BasicExample":::

Шаблон свойства соответствует выражению, если результат выражения не равен NULL, а каждый вложенный шаблон соответствует соответствующему свойству или полю результата выражения.

Вы также можете добавить в шаблон свойства проверку типа среды выполнения и объявление переменной, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/PropertyPattern.cs" id="WithTypeCheck":::

Шаблон свойства является рекурсивным шаблоном. Это значит, что любой шаблон можно использовать как вложенный шаблон. Используйте шаблон свойства для сопоставления элементов данных с вложенными шаблонами, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/PropertyPattern.cs" id="RecursivePropertyPattern":::

В предыдущем примере используются две возможности, доступные в C# 9.0 и более поздних версиях языка: [блок объединения шаблонов](#logical-patterns) `or`и [типы записей](../builtin-types/record.md).

Дополнительные сведения см. в разделе [Шаблон свойства ](~/_csharplang/proposals/csharp-8.0/patterns.md#property-pattern) в примечании к предлагаемой функции.

## <a name="positional-pattern"></a>Позиционный шаблон

Начиная с C# 8.0, вы можете использовать *позиционный шаблон* для деконструкции результата выражения и сравнения результирующих значений с соответствующими вложенными шаблонами, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/PositionalPattern.cs" id="BasicExample":::

В предыдущем примере тип выражения содержит метод [Deconstruct](../../deconstruct.md), используемый для деконструкции результата выражения. Можно также сопоставлять выражения [кортежных типов](../builtin-types/value-tuples.md) с позиционными шаблонами. Таким образом можно сопоставить несколько входных значений с различными шаблонами, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/PositionalPattern.cs" id="MatchTuple":::

В предыдущем примере используются [реляционные](#relational-patterns) и [логические](#logical-patterns) шаблоны, доступные в C# 9.0 и более поздних версиях языка.

В позиционном шаблоне можно использовать имена элементов кортежа и параметры метода `Deconstruct`, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/PositionalPattern.cs" id="UseIdentifiers":::

Можно также расширить позиционный шаблон одним из следующих способов:

- Добавьте проверку типа среды выполнения и объявление переменной, как показано в следующем примере:

  :::code language="csharp" source="snippets/patterns/PositionalPattern.cs" id="WithTypeCheck":::

  В предыдущем примере используются [позиционные записи](../builtin-types/record.md#positional-syntax-for-property-definition), которые неявно обеспечивают выполнение метода `Deconstruct`.

- Используйте [шаблон свойства](#property-pattern) в позиционном шаблоне, как показано в следующем примере:

  :::code language="csharp" source="snippets/patterns/PositionalPattern.cs" id="WithPropertyPattern":::

- Можно объединить два предыдущих варианта, как показано в следующем примере:

  :::code language="csharp" source="snippets/patterns/PositionalPattern.cs" id="CompletePositionalPattern":::

Позиционный шаблон является рекурсивным шаблоном. Это значит, что любой шаблон можно использовать как вложенный шаблон.

Дополнительные сведения см. в разделе [Позиционный шаблон](~/_csharplang/proposals/csharp-8.0/patterns.md#positional-pattern) в примечании к предлагаемой функции.

## <a name="var-pattern"></a>Шаблон `var`

Начиная с C# 7.0, *шаблон* `var` можно использовать для сопоставления любого выражения, включая `null`, и присвоения результата сопоставления новой локальной переменной, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/VarPattern.cs" id="KeepInterimResult":::

Шаблон `var` полезно использовать, если в логическом выражении вам требуется временная переменная для хранения результатов промежуточных вычислений. Шаблон `var` также можно использовать, если требуется реализовать дополнительные проверки в условиях регистра `when` выражения или оператора `switch`, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/VarPattern.cs" id="WithCaseGuards":::

В предыдущем примере шаблон `var (x, y)` эквивалентен [позиционному шаблону ](#positional-pattern) `(var x, var y)`.

В шаблоне `var` тип объявленной переменной равен установленному во время компиляции типу выражения, сопоставляемого с данным шаблоном.

Дополнительные сведения см. в разделе [Шаблон var](~/_csharplang/proposals/csharp-8.0/patterns.md#var-pattern) в примечании к предлагаемой функции.

## <a name="discard-pattern"></a>Шаблон пустой переменной

Начиная с C# 8.0, *шаблон пустой переменной* `_` используется для сопоставления любых выражений, включая `null`, как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/DiscardPattern.cs" id="BasicExample":::

В предыдущем примере шаблон пустой переменной используется для обработки значения `null` и любых целочисленных значений, которые не соответствуют имеющимся членам перечисления <xref:System.DayOfWeek>. Благодаря этому гарантируется, что выражение `switch` в приведенном примере сможет обработать все возможные входные значения. Если в выражении `switch` не используется шаблон пустой переменной и при этом ни один из шаблонов выражения не соответствует входным данным, среда выполнения [генерирует исключение](switch-expression.md#non-exhaustive-switch-expressions). Если выражение `switch` не обрабатывает все возможные входные значения, компилятор генерирует предупреждение.

Шаблон пустой переменной не может быть шаблоном в выражении `is` или операторе `switch`. В этих случаях для сопоставления выражений используйте [шаблон](#var-pattern) `var` с пустой переменной: `var _`.

Дополнительные сведения см. в разделе [Шаблон пустой переменной](~/_csharplang/proposals/csharp-8.0/patterns.md#discard-pattern) в примечании к предлагаемой функции.

## <a name="parenthesized-pattern"></a>Шаблон в круглых скобках

Начиная с C# 9.0, вы можете использовать круглые скобки вокруг любого шаблона. Как правило, это делается для того, чтобы подчеркнуть или изменить приоритет [логических шаблонов](#logical-patterns), как показано в следующем примере:

:::code language="csharp" source="snippets/patterns/LogicalPatterns.cs" id="ChangedPrecedence":::

## <a name="c-language-specification"></a>Спецификация языка C#

Дополнительные сведения см. в следующих примечаниях к предлагаемой функции.

- [Сопоставление шаблонов в C# 7.0](~/_csharplang/proposals/csharp-7.0/pattern-matching.md)
- [Рекурсивное сопоставление шаблонов (впервые представлено в C# 8.0)](~/_csharplang/proposals/csharp-8.0/patterns.md)
- [Изменения в сопоставлении шаблонов в C# 9.0](~/_csharplang/proposals/csharp-9.0/patterns3.md)

## <a name="see-also"></a>См. также

- [справочник по C#](../index.md)
- [Операторы и выражения C#](index.md)
- [Учебник. Использование сопоставления шаблонов для создания управляемых типами и управляемых данными алгоритмов](../../tutorials/pattern-matching.md)
