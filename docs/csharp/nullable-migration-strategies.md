---
title: Обновление базы кода для использования ссылочных типов, допускающих значения null
description: Выбор оптимальной стратегии обновления базы кода для использования ссылочных типов, допускающих значения null.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: ab0970247c7e3f3c20d7fdb40ef035c4ba1d8b01
ms.sourcegitcommit: 30e9e11dfd90112b8eec6406186ba3533f21eba1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2020
ms.locfileid: "97866826"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="2661f-103">Обновление библиотек для использования ссылочных типов, допускающих значения null, и передача правил использования значений null в вызывающие объекты</span><span class="sxs-lookup"><span data-stu-id="2661f-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="2661f-104">Добавление [ссылочных типов, допускающих значения null,](nullable-references.md) означает, что для каждой переменной можно объявить, является ли значение `null` допустимым или ожидаемым.</span><span class="sxs-lookup"><span data-stu-id="2661f-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="2661f-105">Кроме того, можно применить ряд атрибутов: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen` и `NotNullIfNotNull`, чтобы полностью описать состояния значения null для аргументов и возвращаемых значений.</span><span class="sxs-lookup"><span data-stu-id="2661f-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="2661f-106">Это обеспечивает высокое удобство при написании кода.</span><span class="sxs-lookup"><span data-stu-id="2661f-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="2661f-107">В ситуациях, когда переменной, не допускающей значение null, может быть присвоено значение `null`, появляются предупреждения.</span><span class="sxs-lookup"><span data-stu-id="2661f-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="2661f-108">Вы получите предупреждение, если переменная, допускающая значение null, не проверяется на значение null перед разыменованием.</span><span class="sxs-lookup"><span data-stu-id="2661f-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="2661f-109">Обновление библиотек может занять некоторое время, но результат того стоит.</span><span class="sxs-lookup"><span data-stu-id="2661f-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="2661f-110">Чем больше информации вы предоставите компилятору о том, *когда* разрешены или запрещены значения `null`, тем полезнее будут предупреждения для пользователей вашего API.</span><span class="sxs-lookup"><span data-stu-id="2661f-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="2661f-111">Начнем со знакомого примера.</span><span class="sxs-lookup"><span data-stu-id="2661f-111">Let's start with a familiar example.</span></span> <span data-ttu-id="2661f-112">Представьте, что библиотека содержит следующий API для получения строки ресурса.</span><span class="sxs-lookup"><span data-stu-id="2661f-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="2661f-113">В предыдущем примере применяется знакомый шаблон `Try*` в .NET.</span><span class="sxs-lookup"><span data-stu-id="2661f-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="2661f-114">Для этого API существует два ссылочных аргумента: `key` и параметр `message`.</span><span class="sxs-lookup"><span data-stu-id="2661f-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="2661f-115">У этого API есть следующие правила, относящиеся к значениям NULL этих аргументов.</span><span class="sxs-lookup"><span data-stu-id="2661f-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="2661f-116">Вызывающие объекты не должны передавать `null` в качестве аргумента для `key`.</span><span class="sxs-lookup"><span data-stu-id="2661f-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="2661f-117">Вызывающие объекты могут передавать переменную, значение которой равно `null`, в качестве аргумента для `message`.</span><span class="sxs-lookup"><span data-stu-id="2661f-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="2661f-118">Если метод `TryGetMessage` возвращает `true`, значение `message` не равно NULL.</span><span class="sxs-lookup"><span data-stu-id="2661f-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="2661f-119">Если возвращаемое значение равно `false,`, значение `message` (и его состояние со значением NULL) равно NULL.</span><span class="sxs-lookup"><span data-stu-id="2661f-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="2661f-120">Правило для `key` может быть полностью выражено типом переменной: `key` должен быть ссылочным типом, не допускающим значения null.</span><span class="sxs-lookup"><span data-stu-id="2661f-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="2661f-121">Параметр `message` является более сложным.</span><span class="sxs-lookup"><span data-stu-id="2661f-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="2661f-122">Он допускает использование `null` в качестве аргумента, но гарантирует, что в случае успеха аргумент `out` не будет иметь значение NULL.</span><span class="sxs-lookup"><span data-stu-id="2661f-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="2661f-123">В таких случаях требуется более широкое описание ожиданий.</span><span class="sxs-lookup"><span data-stu-id="2661f-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="2661f-124">Обновление библиотеки для использования ссылочных типов, допускающих значение null, требует больше, чем просто добавления `?` к некоторым переменным и именам типов.</span><span class="sxs-lookup"><span data-stu-id="2661f-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="2661f-125">В предыдущем примере показано, что необходимо изучить API и учесть свои ожидания для каждого входного аргумента.</span><span class="sxs-lookup"><span data-stu-id="2661f-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="2661f-126">Учтите гарантии для возвращаемого значения и любых аргументов `out` или `ref` при возврате значения методом.</span><span class="sxs-lookup"><span data-stu-id="2661f-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="2661f-127">Затем сообщите эти правила компилятору, и компилятор будет выдавать предупреждения, когда вызывающие объекты не соблюдают эти правила.</span><span class="sxs-lookup"><span data-stu-id="2661f-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="2661f-128">Эта работа занимает некоторое время.</span><span class="sxs-lookup"><span data-stu-id="2661f-128">This work takes time.</span></span> <span data-ttu-id="2661f-129">Начнем со стратегий, позволяющих библиотеке или приложению работать со значениями null, при этом соблюдая баланс других требований.</span><span class="sxs-lookup"><span data-stu-id="2661f-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements.</span></span> <span data-ttu-id="2661f-130">Вы узнаете, как сбалансировать текущую разработку, разрешив ссылочные типы, допускающие значения null.</span><span class="sxs-lookup"><span data-stu-id="2661f-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="2661f-131">Вы узнаете о проблемах, связанных с определением универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="2661f-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="2661f-132">Вы узнаете, как применять атрибуты для описания предварительных и последующих условий для отдельных API.</span><span class="sxs-lookup"><span data-stu-id="2661f-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="2661f-133">Выбор стратегии для ссылочных типов, допускающих значения null</span><span class="sxs-lookup"><span data-stu-id="2661f-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="2661f-134">Первый вариант заключается во включении или отключении ссылочных типов, допускающих значения null, по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="2661f-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="2661f-135">Существует две стратегии.</span><span class="sxs-lookup"><span data-stu-id="2661f-135">You have two strategies:</span></span>

- <span data-ttu-id="2661f-136">Включить ссылочные типы, допускающие значение null, для всего проекта и отключить их в коде, который к ним не готов.</span><span class="sxs-lookup"><span data-stu-id="2661f-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="2661f-137">Включить ссылочные типы, допускающие значение null, только для кода, аннотированного для ссылочных типов, допускающих значение null.</span><span class="sxs-lookup"><span data-stu-id="2661f-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="2661f-138">Первая стратегия лучше всего подходит, когда помимо обновления библиотеки для ссылочных типов, допускающих значение null, вы также добавляете в нее другие функции.</span><span class="sxs-lookup"><span data-stu-id="2661f-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="2661f-139">Все новые разработки поддерживают значение null.</span><span class="sxs-lookup"><span data-stu-id="2661f-139">All new development is nullable aware.</span></span> <span data-ttu-id="2661f-140">При обновлении существующего кода в этих классах включаются ссылочные типы, допускающие значения NULL.</span><span class="sxs-lookup"><span data-stu-id="2661f-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="2661f-141">В рамках первой стратегии необходимо выполнить следующие действия.</span><span class="sxs-lookup"><span data-stu-id="2661f-141">Following this first strategy, you do the following steps:</span></span>

1. <span data-ttu-id="2661f-142">Включить ссылочные типы, допускающие значение null, для всего проекта, добавив элемент `<Nullable>enable</Nullable>` в файлы *csproj*.</span><span class="sxs-lookup"><span data-stu-id="2661f-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="2661f-143">Добавить прагму `#nullable disable` в каждый исходный файл в проекте.</span><span class="sxs-lookup"><span data-stu-id="2661f-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="2661f-144">Работая с каждым файлом, удалите эту прагму и устраните все предупреждения.</span><span class="sxs-lookup"><span data-stu-id="2661f-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="2661f-145">Первая стратегия предполагает наличие подготовительной работы по добавлению прагмы в каждый файл.</span><span class="sxs-lookup"><span data-stu-id="2661f-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="2661f-146">Преимущество заключается в том, что для каждого нового файла кода, добавленного в проект, будет разрешено значение null.</span><span class="sxs-lookup"><span data-stu-id="2661f-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="2661f-147">Любая новая работа будет поддерживать значения null; необходимо будет обновить только существующий код.</span><span class="sxs-lookup"><span data-stu-id="2661f-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="2661f-148">Вторая стратегия работает лучше, если библиотека является стабильной, и основной задачей разработки является внедрение ссылочных типов, допускающих значение null.</span><span class="sxs-lookup"><span data-stu-id="2661f-148">The second strategy works better if the library is stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="2661f-149">Ссылочные типы, допускающие значение null, включаются по мере аннотирования API.</span><span class="sxs-lookup"><span data-stu-id="2661f-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="2661f-150">По завершении работы ссылочные типы, допускающие значение null, включаются для всего проекта.</span><span class="sxs-lookup"><span data-stu-id="2661f-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="2661f-151">В рамках второй стратегии необходимо выполнить следующие действия.</span><span class="sxs-lookup"><span data-stu-id="2661f-151">Following this second strategy you do the following steps:</span></span>

1. <span data-ttu-id="2661f-152">Добавить прагму `#nullable enable` в файл, в котором необходимо включить поддержку значений null.</span><span class="sxs-lookup"><span data-stu-id="2661f-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="2661f-153">Устранить все предупреждения.</span><span class="sxs-lookup"><span data-stu-id="2661f-153">Address any warnings.</span></span>
1. <span data-ttu-id="2661f-154">Продолжать выполнение первых двух шагов, пока значения null не будет поддерживать вся библиотека.</span><span class="sxs-lookup"><span data-stu-id="2661f-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="2661f-155">Включить типы, допускающие значение null, для всего проекта, добавив элемент `<Nullable>enable</Nullable>` в файлы *csproj*.</span><span class="sxs-lookup"><span data-stu-id="2661f-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="2661f-156">Удалить прагмы `#nullable enable`, так как они больше не нужны.</span><span class="sxs-lookup"><span data-stu-id="2661f-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="2661f-157">Вторая стратегия требует меньше подготовительной работы.</span><span class="sxs-lookup"><span data-stu-id="2661f-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="2661f-158">Компромисс заключается в том, что при создании нового файла в первую очередь необходимо добавить прагму и сделать его поддерживающим значение null.</span><span class="sxs-lookup"><span data-stu-id="2661f-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="2661f-159">Если кто-то из разработчиков вашей команды забудет это сделать, новый код перейдет в разряд невыполненной работы по включению во всем коде поддержки значений null.</span><span class="sxs-lookup"><span data-stu-id="2661f-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="2661f-160">Выбор стратегии зависит от объема активной разработки в проекте.</span><span class="sxs-lookup"><span data-stu-id="2661f-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="2661f-161">Чем более проект зрелый и стабильный, тем лучше работает вторая стратегия.</span><span class="sxs-lookup"><span data-stu-id="2661f-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="2661f-162">Чем больше возможностей находится в разработке, тем лучше работает первая стратегия.</span><span class="sxs-lookup"><span data-stu-id="2661f-162">The more features being developed, the better the first strategy.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2661f-163">Глобальный контекст, допускающий значения NULL, не применяется для созданных файлов кода.</span><span class="sxs-lookup"><span data-stu-id="2661f-163">The global nullable context does not apply for generated code files.</span></span> <span data-ttu-id="2661f-164">В любом случае контекст, допускающий значение NULL, *отключен* для любого исходного файла, помеченного как созданный.</span><span class="sxs-lookup"><span data-stu-id="2661f-164">Under either strategy, the nullable context is *disabled* for any source file marked as generated.</span></span> <span data-ttu-id="2661f-165">Это означает, что все интерфейсы API в создаваемых файлах не заносятся в заметки.</span><span class="sxs-lookup"><span data-stu-id="2661f-165">This means any APIs in generated files are not annotated.</span></span> <span data-ttu-id="2661f-166">Существует четыре способа пометки файла как созданного:</span><span class="sxs-lookup"><span data-stu-id="2661f-166">There are four ways a file is marked as generated:</span></span>
>
> 1. <span data-ttu-id="2661f-167">В файле. editorconfig укажите `generated_code = true` в разделе, который применяется к этому файлу.</span><span class="sxs-lookup"><span data-stu-id="2661f-167">In the .editorconfig, specify `generated_code = true` in a section that applies to that file.</span></span>
> 1. <span data-ttu-id="2661f-168">Вставьте `<auto-generated>` или `<auto-generated/>` в комментарий в верхней части файла.</span><span class="sxs-lookup"><span data-stu-id="2661f-168">Put `<auto-generated>` or `<auto-generated/>` in a comment at the top of the file.</span></span> <span data-ttu-id="2661f-169">Он может находиться в любой строке комментария, однако блок комментариев должен быть первым элементом в файле.</span><span class="sxs-lookup"><span data-stu-id="2661f-169">It can be on any line in that comment, but the comment block must be the first element in the file.</span></span>
> 1. <span data-ttu-id="2661f-170">Имя файла следует начинать с *TemporaryGeneratedFile_*</span><span class="sxs-lookup"><span data-stu-id="2661f-170">Start the file name with *TemporaryGeneratedFile_*</span></span>
> 1. <span data-ttu-id="2661f-171">В конце имени файла следует указать *.designer.cs*, *.generated.cs*, *.g.cs* или *.g.i.cs*.</span><span class="sxs-lookup"><span data-stu-id="2661f-171">End the file name with *.designer.cs*, *.generated.cs*, *.g.cs*, or *.g.i.cs*.</span></span>
>
> <span data-ttu-id="2661f-172">Генераторы могут явно использовать директиву препроцессора [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md).</span><span class="sxs-lookup"><span data-stu-id="2661f-172">Generators can opt-in using the [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md) preprocessor directive.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="2661f-173">Приводят ли предупреждения о значениях null к внесению критических изменений?</span><span class="sxs-lookup"><span data-stu-id="2661f-173">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="2661f-174">До включения ссылочных типов, допускающих значения null, переменные считаются *игнорирующими значения null*.</span><span class="sxs-lookup"><span data-stu-id="2661f-174">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="2661f-175">После включения ссылочных типов, допускающих значения null, все эти переменные станут *не допускающими значения null*.</span><span class="sxs-lookup"><span data-stu-id="2661f-175">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="2661f-176">Если эти переменные не инициализируются значениями, отличными от null, компилятор выдаст предупреждение.</span><span class="sxs-lookup"><span data-stu-id="2661f-176">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="2661f-177">Другой вероятный источник предупреждений — возвращаемое значение, если оно не было инициализировано.</span><span class="sxs-lookup"><span data-stu-id="2661f-177">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="2661f-178">Первым шагом в исправлении предупреждений компилятора является добавление заметок `?` к параметрам и возвращаемым типам, чтобы указать, когда аргументы или возвращаемые значения могут иметь значение null.</span><span class="sxs-lookup"><span data-stu-id="2661f-178">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="2661f-179">Если ссылочные переменные не должны иметь значение null, исходное объявление будет правильным.</span><span class="sxs-lookup"><span data-stu-id="2661f-179">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="2661f-180">При выполнении этой задачи ваша цель заключается не только в устранении предупреждений.</span><span class="sxs-lookup"><span data-stu-id="2661f-180">As you do this task, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="2661f-181">Более важная задача заключается в том, чтобы компилятор понял смысл возможных значений null.</span><span class="sxs-lookup"><span data-stu-id="2661f-181">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="2661f-182">Изучив предупреждения, вы подойдете к следующему важному решению в отношении своей библиотеки.</span><span class="sxs-lookup"><span data-stu-id="2661f-182">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="2661f-183">Вы хотите изменить сигнатуры API, чтобы более четко сообщить намерения разработчика?</span><span class="sxs-lookup"><span data-stu-id="2661f-183">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="2661f-184">Улучшенная сигнатура API для метода `TryGetMessage`, изученного ранее, может выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="2661f-184">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="2661f-185">Возвращаемое значение указывает на успех или сбой и содержит значение, если значение было найдено.</span><span class="sxs-lookup"><span data-stu-id="2661f-185">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="2661f-186">Во многих случаях изменение сигнатур API может улучшить способ передачи значений null.</span><span class="sxs-lookup"><span data-stu-id="2661f-186">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="2661f-187">Однако для общедоступных библиотек или библиотек с большой пользовательской базой вы, вероятно, не захотите вносить изменения в сигнатуры API.</span><span class="sxs-lookup"><span data-stu-id="2661f-187">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="2661f-188">В таких случаях и других распространенных шаблонах можно применять атрибуты для более четкого определения того, когда аргумент или возвращаемое значение могут иметь значение `null`.</span><span class="sxs-lookup"><span data-stu-id="2661f-188">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="2661f-189">Независимо от того, рассматриваете ли вы изменение поверхности API или нет, скорее всего, вы обнаружите, что одних аннотаций типа недостаточно для описания значений `null` для аргументов и возвращаемых значений.</span><span class="sxs-lookup"><span data-stu-id="2661f-189">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="2661f-190">В этих случаях можно применять атрибуты для более четкого описания API.</span><span class="sxs-lookup"><span data-stu-id="2661f-190">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="2661f-191">Атрибуты расширяют аннотации типов</span><span class="sxs-lookup"><span data-stu-id="2661f-191">Attributes extend type annotations</span></span>

<span data-ttu-id="2661f-192">Для выражения дополнительных сведений о состоянии NULL для переменных добавлено несколько атрибутов.</span><span class="sxs-lookup"><span data-stu-id="2661f-192">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="2661f-193">Весь код, написанный до ввода ссылочных типов, допускающих значение NULL, в C# версии 8, *игнорировал допустимость значений NULL*.</span><span class="sxs-lookup"><span data-stu-id="2661f-193">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="2661f-194">Это означает, что любая переменная ссылочного типа может принимать значение NULL, но проверки значений NULL не требуются.</span><span class="sxs-lookup"><span data-stu-id="2661f-194">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="2661f-195">Но если код *допускает значения NULL*, эти правила меняются.</span><span class="sxs-lookup"><span data-stu-id="2661f-195">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="2661f-196">Ссылочные типы никогда не должны быть значением `null`, а ссылочные типы, допускающие значения NULL, перед разыменованием должны проверяться на наличие `null`.</span><span class="sxs-lookup"><span data-stu-id="2661f-196">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="2661f-197">Правила для API-интерфейсов, по всей вероятности, более сложны, как было показано в сценарии `TryGetValue` API.</span><span class="sxs-lookup"><span data-stu-id="2661f-197">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="2661f-198">Для многих API действуют более сложные правила в отношении того, когда переменные могут или не могут иметь значение `null`.</span><span class="sxs-lookup"><span data-stu-id="2661f-198">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="2661f-199">В таких случаях для выражения этих правил используются атрибуты.</span><span class="sxs-lookup"><span data-stu-id="2661f-199">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="2661f-200">Атрибуты, описывающие семантику API, см. в статье, посвященной [атрибутам, влияющим на анализ значений null](./language-reference/attributes/nullable-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="2661f-200">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="2661f-201">Универсальные определения и допустимость значений null</span><span class="sxs-lookup"><span data-stu-id="2661f-201">Generic definitions and nullability</span></span>

<span data-ttu-id="2661f-202">Правильная передача состояния null универсальных типов и универсальных методов требует особой осторожности.</span><span class="sxs-lookup"><span data-stu-id="2661f-202">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="2661f-203">Особое внимание уделяется тому факту, что тип значения, допускающий значение null, и ссылочный тип, допускающий значения null, являются фундаментально разными.</span><span class="sxs-lookup"><span data-stu-id="2661f-203">The extra care stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="2661f-204">`int?` является синонимом `Nullable<int>`, тогда как `string?` является `string` с атрибутом, добавленным компилятором.</span><span class="sxs-lookup"><span data-stu-id="2661f-204">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="2661f-205">В результате компилятор не может создать правильный код для `T?`, не зная, является ли `T` `class` или `struct`.</span><span class="sxs-lookup"><span data-stu-id="2661f-205">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="2661f-206">Этот факт не означает, что нельзя использовать тип, допускающий значение null (тип значения или ссылочный тип), в качестве аргумента типа для закрытого универсального типа.</span><span class="sxs-lookup"><span data-stu-id="2661f-206">This fact doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="2661f-207">`List<string?>` и `List<int?>` являются допустимыми экземплярами `List<T>`.</span><span class="sxs-lookup"><span data-stu-id="2661f-207">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="2661f-208">В действительности это означает, что нельзя использовать `T?` в объявлении универсального класса или метода без ограничений.</span><span class="sxs-lookup"><span data-stu-id="2661f-208">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="2661f-209">Например, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> не будет изменен для возврата `T?`.</span><span class="sxs-lookup"><span data-stu-id="2661f-209">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="2661f-210">Это ограничение можно преодолеть, добавив ограничение `struct` или `class`.</span><span class="sxs-lookup"><span data-stu-id="2661f-210">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="2661f-211">При указании любого из этих ограничений компилятор будет знать, как создавать код для `T` и `T?`.</span><span class="sxs-lookup"><span data-stu-id="2661f-211">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="2661f-212">Может потребоваться ограничить типы, используемые для аргумента универсального типа, типами, не допускающими значения null.</span><span class="sxs-lookup"><span data-stu-id="2661f-212">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="2661f-213">Это можно сделать, добавив ограничение `notnull` для этого аргумента типа.</span><span class="sxs-lookup"><span data-stu-id="2661f-213">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="2661f-214">При применении этого ограничения аргумент типа должен быть типом, не допускающим значение null.</span><span class="sxs-lookup"><span data-stu-id="2661f-214">When that constraint is applied, the type argument must not be a nullable type.</span></span>

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a><span data-ttu-id="2661f-215">Свойства с поздней инициализацией, объекты передачи данных и допустимость значений null</span><span class="sxs-lookup"><span data-stu-id="2661f-215">Late-initialized properties, Data Transfer Objects, and nullability</span></span>

<span data-ttu-id="2661f-216">Указание допустимости значений null для свойств с поздней инициализацией, то есть задаваемых после создания, может потребовать особого внимания, чтобы класс продолжал правильно выражать первоначальное намерение разработчика.</span><span class="sxs-lookup"><span data-stu-id="2661f-216">Indicating the nullability of properties that are late-initialized, meaning set after construction, may require special consideration to ensure that your class continues to correctly express the original design intent.</span></span>

<span data-ttu-id="2661f-217">Типы, содержащие свойства с поздней инициализацией, такие как объекты передачи данных (DTO), часто создаются внешней библиотекой, например базой данных ORM (реляционный сопоставитель объектов), десериализатором или каким-либо другим компонентом, который автоматически заполняет свойства из другого источника.</span><span class="sxs-lookup"><span data-stu-id="2661f-217">Types that contain late-initialized properties, such as Data Transfer Objects (DTOs), are often instantiated by an external library, like a database ORM (Object Relational Mapper), a deserializer, or some other component that automatically populates properties from another source.</span></span>

<span data-ttu-id="2661f-218">Перед включением ссылочных типов, допускающих значение null, рассмотрим следующий класс DTO, который представляет учащегося:</span><span class="sxs-lookup"><span data-stu-id="2661f-218">Consider the following DTO class, prior to enabling nullable reference types, that represents a student:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

<span data-ttu-id="2661f-219">Цель разработки (указанная в этом случае атрибутом `Required`) предполагает, что в этой системе свойства `FirstName` и `LastName` являются **обязательными** и, следовательно, не могут иметь значение null.</span><span class="sxs-lookup"><span data-stu-id="2661f-219">The design intent (indicated in this case by the `Required` attribute) suggests that in this system, the `FirstName` and `LastName` properties are **mandatory**, and therefore not null.</span></span>

<span data-ttu-id="2661f-220">Свойство `VehicleRegistration` **не является обязательным**, поэтому может иметь значение null.</span><span class="sxs-lookup"><span data-stu-id="2661f-220">The `VehicleRegistration` property is **not mandatory**, so may be null.</span></span>

<span data-ttu-id="2661f-221">При включении ссылочных типов, допускающих значения null, необходимо указать, какие свойства в DTO могут допускать значение null, в соответствии с исходным намерением:</span><span class="sxs-lookup"><span data-stu-id="2661f-221">When you enable nullable reference types, you want to indicate which properties on your DTO may be nullable, consistent with your original intent:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="2661f-222">В этом примере в объекте DTO единственным свойством, которое может иметь значение null, является ``VehicleRegistration``.</span><span class="sxs-lookup"><span data-stu-id="2661f-222">For this DTO, the only property that may be null is ``VehicleRegistration``.</span></span>

<span data-ttu-id="2661f-223">Однако компилятор создает предупреждения `CS8618` как для `FirstName`, так и для `LastName`, указывая, что свойства, не допускающие значения null, не инициализированы.</span><span class="sxs-lookup"><span data-stu-id="2661f-223">However, the compiler raises `CS8618` warnings for both `FirstName` and `LastName`, indicating the non-nullable properties are uninitialized.</span></span>

<span data-ttu-id="2661f-224">Существует три варианта разрешения предупреждений компилятора таким образом, чтобы сохранить исходное намерение.</span><span class="sxs-lookup"><span data-stu-id="2661f-224">There are three options available to you that resolve the compiler warnings in a way that maintains the original intent.</span></span> <span data-ttu-id="2661f-225">Все эти варианты являются допустимыми, поэтому можно выбрать тот, который лучше подходит к стилю написания кода и требованиям к разработке.</span><span class="sxs-lookup"><span data-stu-id="2661f-225">Any of these options are valid; you should choose the one that best suits your coding style and design requirements.</span></span>

### <a name="initialize-in-the-constructor"></a><span data-ttu-id="2661f-226">Инициализация в конструкторе</span><span class="sxs-lookup"><span data-stu-id="2661f-226">Initialize in the constructor</span></span>

<span data-ttu-id="2661f-227">Идеальным способом устранения неинициализированных предупреждений является инициализация свойств в конструкторе:</span><span class="sxs-lookup"><span data-stu-id="2661f-227">The ideal way to resolve the uninitialized warnings is to initialize the properties in the constructor:</span></span>

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="2661f-228">Этот подход работает только в том случае, если библиотека, используемая для создания экземпляра класса, поддерживает передачу параметров в конструктор.</span><span class="sxs-lookup"><span data-stu-id="2661f-228">This approach only works if the library that you use to instantiate the class supports passing parameters in the constructor.</span></span>

<span data-ttu-id="2661f-229">Библиотека может поддерживать передачу *некоторых* свойств в конструктор, но не все.</span><span class="sxs-lookup"><span data-stu-id="2661f-229">A library may support passing *some* properties in the constructor, but not all.</span></span> <span data-ttu-id="2661f-230">Например, EF Core поддерживает [привязку конструктора](/ef/core/modeling/constructors) для обычных свойств столбца, но не для свойств навигации.</span><span class="sxs-lookup"><span data-stu-id="2661f-230">For example, EF Core supports [constructor binding](/ef/core/modeling/constructors) for normal column properties, but not navigation properties.</span></span>

<span data-ttu-id="2661f-231">Ознакомьтесь с документацией по библиотеке, которая создает экземпляр класса, чтобы понять, в какой степени она поддерживает привязку конструктора.</span><span class="sxs-lookup"><span data-stu-id="2661f-231">Check the documentation on the library that instantiates your class, to understand the extent to which it supports constructor binding.</span></span>

### <a name="property-with-nullable-backing-field"></a><span data-ttu-id="2661f-232">Свойство с резервным полем, допускающим значение null</span><span class="sxs-lookup"><span data-stu-id="2661f-232">Property with nullable backing field</span></span>

<span data-ttu-id="2661f-233">Если привязка конструктора вам не подходит, одним из способов решения этой проблемы является наличие свойства, не допускающего значения null, с резервным полем, допускающим значение null.</span><span class="sxs-lookup"><span data-stu-id="2661f-233">If constructor binding won't work for you, one way to deal with this problem is to have a non-nullable property with a nullable backing field:</span></span>

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

<span data-ttu-id="2661f-234">В этом сценарии, если доступ к свойству `FirstName` осуществляется до инициализации, код создает исключение `InvalidOperationException`, так как контракт API используется неправильно.</span><span class="sxs-lookup"><span data-stu-id="2661f-234">In this scenario, if the `FirstName` property is accessed before it has been initialized, then the code throws an `InvalidOperationException`, because the API contract has been used incorrectly.</span></span>

<span data-ttu-id="2661f-235">Учтите, что для некоторых библиотек могут иметься особые соображения при использовании резервных полей.</span><span class="sxs-lookup"><span data-stu-id="2661f-235">Consider that some libraries may have special considerations when using backing fields.</span></span> <span data-ttu-id="2661f-236">Например, в EF Core может потребоваться настройка для правильного использования [резервных полей](/ef/core/modeling/backing-field).</span><span class="sxs-lookup"><span data-stu-id="2661f-236">For example, EF Core may need to be configured to use [backing fields](/ef/core/modeling/backing-field) correctly.</span></span>

### <a name="initialize-the-property-to-null"></a><span data-ttu-id="2661f-237">Инициализация свойства значением null</span><span class="sxs-lookup"><span data-stu-id="2661f-237">Initialize the property to null</span></span>

<span data-ttu-id="2661f-238">В качестве более краткой альтернативы использованию резервного поля, допускающего значение null, или если библиотека, которая создает экземпляр класса, несовместима с этим подходом, можно напрямую инициализировать свойство значением `null` с помощью оператора, разрешающего значение null (`!`):</span><span class="sxs-lookup"><span data-stu-id="2661f-238">As a terser alternative to using a nullable backing field, or if the library that instantiates your class isn't compatible with that approach, you can initialize the property to `null` directly, with the help of the null-forgiving operator (`!`):</span></span>

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

<span data-ttu-id="2661f-239">Фактическое значение null во время выполнения никогда не проявится, за исключением случаев ошибок программирования, когда обращение к свойству будет происходить до того, как оно будет правильно инициализировано.</span><span class="sxs-lookup"><span data-stu-id="2661f-239">You'll never observe an actual null value at runtime except as a result of a programming bug, by accessing the property before it has been properly initialized.</span></span>

## <a name="see-also"></a><span data-ttu-id="2661f-240">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="2661f-240">See also</span></span>

- [<span data-ttu-id="2661f-241">Перенос существующей базы кода на ссылки, допускающие значение NULL</span><span class="sxs-lookup"><span data-stu-id="2661f-241">Migrate an existing codebase to nullable references</span></span>](tutorials/upgrade-to-nullable-references.md)
- [<span data-ttu-id="2661f-242">Работа со ссылочными типами, допускающими значение null в EF Core</span><span class="sxs-lookup"><span data-stu-id="2661f-242">Working with Nullable Reference Types in EF Core</span></span>](/ef/core/miscellaneous/nullable-reference-types)
