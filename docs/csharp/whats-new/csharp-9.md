---
title: Новые возможности в C# 9.0. Руководство по языку C#
description: Обзор новых функций, доступных в C# 9.0.
ms.date: 04/07/2021
ms.openlocfilehash: e43ecc02fa7fe1f9a0a76353ce0b6bce001f9dac
ms.sourcegitcommit: 5ddbd1f65d0369b4cc8c8ff91c72f1b524c90221
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2021
ms.locfileid: "107514428"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="02978-103">Новые возможности C# 9.0</span><span class="sxs-lookup"><span data-stu-id="02978-103">What's new in C# 9.0</span></span>

<span data-ttu-id="02978-104">В C# 9.0 добавлены следующие функции и улучшения языка C#.</span><span class="sxs-lookup"><span data-stu-id="02978-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="02978-105">Записи</span><span class="sxs-lookup"><span data-stu-id="02978-105">Records</span></span>](#record-types)
- [<span data-ttu-id="02978-106">Методы задания только инициализации</span><span class="sxs-lookup"><span data-stu-id="02978-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="02978-107">Инструкции верхнего уровня</span><span class="sxs-lookup"><span data-stu-id="02978-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="02978-108">Улучшения сопоставления шаблонов</span><span class="sxs-lookup"><span data-stu-id="02978-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- [<span data-ttu-id="02978-109">Производительность и взаимодействие</span><span class="sxs-lookup"><span data-stu-id="02978-109">Performance and interop</span></span>](#performance-and-interop)
  - [<span data-ttu-id="02978-110">Целые числа собственного размера</span><span class="sxs-lookup"><span data-stu-id="02978-110">Native sized integers</span></span>](~/_csharplang/proposals/csharp-9.0/native-integers.md)
  - [<span data-ttu-id="02978-111">Указатели функций</span><span class="sxs-lookup"><span data-stu-id="02978-111">Function pointers</span></span>](~/_csharplang/proposals/csharp-9.0/function-pointers.md)
  - [<span data-ttu-id="02978-112">Отмена создания флага localsinit</span><span class="sxs-lookup"><span data-stu-id="02978-112">Suppress emitting localsinit flag</span></span>](~/_csharplang/proposals/csharp-9.0/skip-localsinit.md)
- [<span data-ttu-id="02978-113">Функции подбора и завершения</span><span class="sxs-lookup"><span data-stu-id="02978-113">Fit and finish features</span></span>](#fit-and-finish-features)
  - [<span data-ttu-id="02978-114">Выражения `new` с целевым типом</span><span class="sxs-lookup"><span data-stu-id="02978-114">Target-typed `new` expressions</span></span>](~/_csharplang/proposals/csharp-9.0/target-typed-new.md)
  - [<span data-ttu-id="02978-115">Анонимные функции `static`</span><span class="sxs-lookup"><span data-stu-id="02978-115">`static` anonymous functions</span></span>](~/_csharplang/proposals/csharp-9.0/static-anonymous-functions.md)
  - [<span data-ttu-id="02978-116">Условное выражение с целевым типом</span><span class="sxs-lookup"><span data-stu-id="02978-116">Target-typed conditional expressions</span></span>](~/_csharplang/proposals/csharp-9.0/target-typed-conditional-expression.md)
  - [<span data-ttu-id="02978-117">Ковариантные возвращаемые типы</span><span class="sxs-lookup"><span data-stu-id="02978-117">Covariant return types</span></span>](~/_csharplang/proposals/csharp-9.0/covariant-returns.md)
  - [<span data-ttu-id="02978-118">Поддержка расширения `GetEnumerator` для циклов `foreach`</span><span class="sxs-lookup"><span data-stu-id="02978-118">Extension `GetEnumerator` support for `foreach` loops</span></span>](~/_csharplang/proposals/csharp-9.0/extension-getenumerator.md)
  - [<span data-ttu-id="02978-119">Параметры удаления лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="02978-119">Lambda discard parameters</span></span>](~/_csharplang/proposals/csharp-9.0/lambda-discard-parameters.md)
  - [<span data-ttu-id="02978-120">Атрибуты локальных функций</span><span class="sxs-lookup"><span data-stu-id="02978-120">Attributes on local functions</span></span>](~/_csharplang/proposals/csharp-9.0/local-function-attributes.md)
- [<span data-ttu-id="02978-121">Поддержка генераторов кода</span><span class="sxs-lookup"><span data-stu-id="02978-121">Support for code generators</span></span>](#support-for-code-generators)
  - [<span data-ttu-id="02978-122">Инициализаторы модулей</span><span class="sxs-lookup"><span data-stu-id="02978-122">Module initializers</span></span>](~/_csharplang/proposals/csharp-9.0/module-initializers.md)
  - [<span data-ttu-id="02978-123">Новые функции для разделяемых методов</span><span class="sxs-lookup"><span data-stu-id="02978-123">New features for partial methods</span></span>](~/_csharplang/proposals/csharp-9.0/extending-partial-methods.md)

<span data-ttu-id="02978-124">C# 9.0 поддерживается в **.NET 5**.</span><span class="sxs-lookup"><span data-stu-id="02978-124">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="02978-125">Дополнительные сведения см. в статье [Управление версиями языка C#](../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="02978-125">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="02978-126">Вы можете скачать последний пакет SDK для .NET на странице [скачиваемых файлов .NET](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="02978-126">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="record-types"></a><span data-ttu-id="02978-127">Типы записей</span><span class="sxs-lookup"><span data-stu-id="02978-127">Record types</span></span>

<span data-ttu-id="02978-128">В C# 9.0 появились ***типы записей***.</span><span class="sxs-lookup"><span data-stu-id="02978-128">C# 9.0 introduces ***record types***.</span></span> <span data-ttu-id="02978-129">Вы можете использовать ключевое слово `record` для определения ссылочного типа, который предоставляет встроенные возможности для инкапсуляции данных.</span><span class="sxs-lookup"><span data-stu-id="02978-129">You use the `record` keyword to define a reference type that provides built-in functionality for encapsulating data.</span></span> <span data-ttu-id="02978-130">Вы можете создавать типы записей с неизменяемыми свойствами, используя позиционные параметры или стандартный синтаксис свойств:</span><span class="sxs-lookup"><span data-stu-id="02978-130">You can create record types with immutable properties by using positional parameters or standard property syntax:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="PositionalRecord":::
:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="ImmutableRecord":::

<span data-ttu-id="02978-131">Кроме того, можно создавать типы записей с изменяемыми свойствами и полями:</span><span class="sxs-lookup"><span data-stu-id="02978-131">You can also create record types with mutable properties and fields:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="MutableRecord":::

<span data-ttu-id="02978-132">Несмотря на поддержку изменения, записи предназначены в первую очередь для неизменяемых моделей данных.</span><span class="sxs-lookup"><span data-stu-id="02978-132">While records can be mutable, they are primarily intended for supporting immutable data models.</span></span> <span data-ttu-id="02978-133">Тип записи предоставляет следующие возможности:</span><span class="sxs-lookup"><span data-stu-id="02978-133">The record type offers the following features:</span></span>

* [<span data-ttu-id="02978-134">Краткий синтаксис для создания ссылочного типа с неизменяемыми свойствами.</span><span class="sxs-lookup"><span data-stu-id="02978-134">Concise syntax for creating a reference type with immutable properties</span></span>](#positional-syntax-for-property-definition)
* <span data-ttu-id="02978-135">Поведение, полезное для ссылочного типа, ориентированного на данные:</span><span class="sxs-lookup"><span data-stu-id="02978-135">Behavior useful for a data-centric reference type:</span></span>
  * [<span data-ttu-id="02978-136">Равенство значений</span><span class="sxs-lookup"><span data-stu-id="02978-136">Value equality</span></span>](#value-equality)
  * [<span data-ttu-id="02978-137">Краткий синтаксис для обратимого изменения.</span><span class="sxs-lookup"><span data-stu-id="02978-137">Concise syntax for nondestructive mutation</span></span>](#nondestructive-mutation)
  * [<span data-ttu-id="02978-138">Встроенное форматирование для отображения.</span><span class="sxs-lookup"><span data-stu-id="02978-138">Built-in formatting for display</span></span>](#built-in-formatting-for-display)
* [<span data-ttu-id="02978-139">Поддержка иерархий наследования.</span><span class="sxs-lookup"><span data-stu-id="02978-139">Support for inheritance hierarchies</span></span>](#inheritance)

<span data-ttu-id="02978-140">На основе [типов структур](../language-reference/builtin-types/struct.md) можно создать типы, ориентированные на данные, которые поддерживают равенство значений и почти не определяют поведение.</span><span class="sxs-lookup"><span data-stu-id="02978-140">You can use [structure types](../language-reference/builtin-types/struct.md) to design data-centric types that provide value equality and little or no behavior.</span></span> <span data-ttu-id="02978-141">Но в сравнительно больших моделях данных типы структур имеют определенные недостатки:</span><span class="sxs-lookup"><span data-stu-id="02978-141">But for relatively large data models, structure types have some disadvantages:</span></span>

* <span data-ttu-id="02978-142">Они не поддерживают наследование.</span><span class="sxs-lookup"><span data-stu-id="02978-142">They don't support inheritance.</span></span>
* <span data-ttu-id="02978-143">Они менее эффективны при определении равенства значений.</span><span class="sxs-lookup"><span data-stu-id="02978-143">They're less efficient at determining value equality.</span></span> <span data-ttu-id="02978-144">Для типов значений метод <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> использует отражение для поиска всех полей.</span><span class="sxs-lookup"><span data-stu-id="02978-144">For value types, the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method uses reflection to find all fields.</span></span> <span data-ttu-id="02978-145">Для записей компилятор создает метод `Equals`.</span><span class="sxs-lookup"><span data-stu-id="02978-145">For records, the compiler generates the `Equals` method.</span></span> <span data-ttu-id="02978-146">На практике реализация равенства значений в записях работает заметно быстрее.</span><span class="sxs-lookup"><span data-stu-id="02978-146">In practice, the implementation of value equality in records is measurably faster.</span></span>
* <span data-ttu-id="02978-147">В некоторых сценариях они используют больше памяти, так как каждый экземпляр содержит полную копию всех данных.</span><span class="sxs-lookup"><span data-stu-id="02978-147">They use more memory in some scenarios, since every instance has a complete copy of all of the data.</span></span> <span data-ttu-id="02978-148">Типы записей являются [ссылочными типами](../language-reference/builtin-types/reference-types.md), то есть каждый экземпляр записи содержит только ссылку на данные.</span><span class="sxs-lookup"><span data-stu-id="02978-148">Record types are [reference types](../language-reference/builtin-types/reference-types.md), so a record instance contains only a reference to the data.</span></span>

### <a name="positional-syntax-for-property-definition"></a><span data-ttu-id="02978-149">Позиционный синтаксис для определения свойств</span><span class="sxs-lookup"><span data-stu-id="02978-149">Positional syntax for property definition</span></span>

<span data-ttu-id="02978-150">Позиционные параметры позволяют объявить свойства записи и инициализировать значения свойств при создании экземпляра:</span><span class="sxs-lookup"><span data-stu-id="02978-150">You can use positional parameters to declare properties of a record and to initialize the property values when you create an instance:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="InstantiatePositional":::

<span data-ttu-id="02978-151">При использовании позиционного синтаксиса для определения свойства компилятор создает следующие элементы:</span><span class="sxs-lookup"><span data-stu-id="02978-151">When you use the positional syntax for property definition, the compiler creates:</span></span>

* <span data-ttu-id="02978-152">Открытое автоматически реализуемое свойство "только init" создается для каждого позиционного параметра, предоставленного в объявлении записи.</span><span class="sxs-lookup"><span data-stu-id="02978-152">A public init-only auto-implemented property for each positional parameter provided in the record declaration.</span></span> <span data-ttu-id="02978-153">Свойство [только init](../language-reference/keywords/init.md) может быть задано только в конструкторе или с помощью инициализатора свойств.</span><span class="sxs-lookup"><span data-stu-id="02978-153">An [init-only](../language-reference/keywords/init.md) property can only be set in the constructor or by using a property initializer.</span></span>
* <span data-ttu-id="02978-154">Основной конструктор, параметры которого соответствуют позиционным параметрам в объявлении записи.</span><span class="sxs-lookup"><span data-stu-id="02978-154">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
* <span data-ttu-id="02978-155">Метод `Deconstruct` с параметром `out` создается для каждого позиционного параметра, предоставленного в объявлении записи.</span><span class="sxs-lookup"><span data-stu-id="02978-155">A `Deconstruct` method with an `out` parameter for each positional parameter provided in the record declaration.</span></span>

<span data-ttu-id="02978-156">Дополнительные сведения см. в разделе [Позиционный синтаксис](../language-reference/builtin-types/record.md#positional-syntax-for-property-definition) статьи, посвященной записям, в справочнике по языку C#.</span><span class="sxs-lookup"><span data-stu-id="02978-156">For more information, see [Positional syntax](../language-reference/builtin-types/record.md#positional-syntax-for-property-definition) in the C# language reference article about records.</span></span>

### <a name="immutability"></a><span data-ttu-id="02978-157">Неизменяемость</span><span class="sxs-lookup"><span data-stu-id="02978-157">Immutability</span></span>

<span data-ttu-id="02978-158">Тип записи не обязательно является неизменяемым.</span><span class="sxs-lookup"><span data-stu-id="02978-158">A record type is not necessarily immutable.</span></span> <span data-ttu-id="02978-159">Вы можете объявить свойства с методами доступа `set` и полями без атрибута `readonly`.</span><span class="sxs-lookup"><span data-stu-id="02978-159">You can declare properties with `set` accessors and fields that aren't `readonly`.</span></span> <span data-ttu-id="02978-160">Но несмотря на поддержку изменения, записи лучше всего подходят для создания неизменяемых моделей данных.</span><span class="sxs-lookup"><span data-stu-id="02978-160">But while records can be mutable, they make it easier to create immutable data models.</span></span> <span data-ttu-id="02978-161">Свойства, создаваемые с использованием позиционного синтаксиса, являются неизменяемыми.</span><span class="sxs-lookup"><span data-stu-id="02978-161">Properties that you create by using positional syntax are immutable.</span></span>

<span data-ttu-id="02978-162">Неизменяемость может быть полезной, если требуется обеспечить потокобезопасность типа, ориентированного на данные, или когда существует необходимость сохранять хэш-код в неизменном виде в хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="02978-162">Immutability can be useful when you want a data-centric type to be thread-safe or a hash code to remain the same in a hash table.</span></span> <span data-ttu-id="02978-163">Это может препятствовать возникновению ошибок, когда, например, вы передаете в метод аргумент по ссылке, и этот метод неожиданно изменяет значение аргумента.</span><span class="sxs-lookup"><span data-stu-id="02978-163">It can prevent bugs that happen when you pass an argument by reference to a method, and the method unexpectedly changes the argument value.</span></span>

<span data-ttu-id="02978-164">Возможности, уникальные для типов записей, реализуются синтезированными компилятором методами, ни один из которых не нарушает неизменяемость путем изменения состояния объекта.</span><span class="sxs-lookup"><span data-stu-id="02978-164">The features unique to record types are implemented by compiler-synthesized methods, and none of these methods compromises immutability by modifying object state.</span></span>

### <a name="value-equality"></a><span data-ttu-id="02978-165">Равенство значений</span><span class="sxs-lookup"><span data-stu-id="02978-165">Value equality</span></span>

<span data-ttu-id="02978-166">Равенство значений означает, что две переменные типа записи считаются равными, если совпадают типы и значения всех свойств и полей.</span><span class="sxs-lookup"><span data-stu-id="02978-166">Value equality means that two variables of a record type are equal if the types match and all property and field values match.</span></span> <span data-ttu-id="02978-167">Для других ссылочных типов равенство означает полную идентичность.</span><span class="sxs-lookup"><span data-stu-id="02978-167">For other reference types, equality means identity.</span></span> <span data-ttu-id="02978-168">То есть две переменные ссылочного типа равны только в том случае, если они ссылаются на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="02978-168">That is, two variables of a reference type are equal if they refer to the same object.</span></span>

<span data-ttu-id="02978-169">Следующий пример демонстрирует равенство значений для типов записей:</span><span class="sxs-lookup"><span data-stu-id="02978-169">The following example illustrates value equality of record types:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="Equality":::

<span data-ttu-id="02978-170">В типах `class` можно вручную переопределить методы и операторы равенства, чтобы реализовать равенство значений, но разработка и тестирование такого кода занимают много времени и могут стать причиной ошибок.</span><span class="sxs-lookup"><span data-stu-id="02978-170">In `class` types, you could manually override equality methods and operators to achieve value equality, but developing and testing that code would be time-consuming and error-prone.</span></span> <span data-ttu-id="02978-171">Если такая функциональность встроена изначально, это позволяет избежать ошибок, которые возникнут, когда вы забудете обновить пользовательский код переопределения при добавлении или изменении свойств или полей.</span><span class="sxs-lookup"><span data-stu-id="02978-171">Having this functionality built-in prevents bugs that would result from forgetting to update custom override code when properties or fields are added or changed.</span></span>

<span data-ttu-id="02978-172">Дополнительные сведения см. в разделе [Равенство значений](../language-reference/builtin-types/record.md#value-equality) статьи, посвященной записям, в справочнике по языку C#.</span><span class="sxs-lookup"><span data-stu-id="02978-172">For more information, see [Value equality](../language-reference/builtin-types/record.md#value-equality) in the C# language reference article about records.</span></span>

### <a name="nondestructive-mutation"></a><span data-ttu-id="02978-173">Обратимое изменение</span><span class="sxs-lookup"><span data-stu-id="02978-173">Nondestructive mutation</span></span>

<span data-ttu-id="02978-174">Если нужно изменить неизменяемые свойства экземпляра записи, вы можете с помощью выражения `with` выполнить *обратимое изменение*.</span><span class="sxs-lookup"><span data-stu-id="02978-174">If you need to mutate immutable properties of a record instance, you can use a `with` expression to achieve *nondestructive mutation*.</span></span> <span data-ttu-id="02978-175">Выражение `with` создает новый экземпляр записи, который является копией существующего экземпляра записи, и изменяет в этой копии указанные свойства и поля.</span><span class="sxs-lookup"><span data-stu-id="02978-175">A `with` expression makes a new record instance that is a copy of an existing record instance, with specified properties and fields modified.</span></span> <span data-ttu-id="02978-176">Для указания требуемых изменений используется синтаксис [инициализатора объектов](../programming-guide/classes-and-structs/object-and-collection-initializers.md), как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="02978-176">You use [object initializer](../programming-guide/classes-and-structs/object-and-collection-initializers.md) syntax to specify the values to be changed, as shown in the following example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="WithExpressions":::

<span data-ttu-id="02978-177">Дополнительные сведения см. в разделе [Обратимое изменение](../language-reference/builtin-types/record.md#nondestructive-mutation) статьи, посвященной записям, в справочнике по языку C#.</span><span class="sxs-lookup"><span data-stu-id="02978-177">For more information, see [Nondestructive mutation](../language-reference/builtin-types/record.md#nondestructive-mutation) in the C# language reference article about records.</span></span>

### <a name="built-in-formatting-for-display"></a><span data-ttu-id="02978-178">Встроенное форматирование для отображения</span><span class="sxs-lookup"><span data-stu-id="02978-178">Built-in formatting for display</span></span>

<span data-ttu-id="02978-179">Типы записей имеют создаваемый компилятором метод <xref:System.Object.ToString%2A>, который отображает имена и значения открытых свойств и полей.</span><span class="sxs-lookup"><span data-stu-id="02978-179">Record types have a compiler-generated <xref:System.Object.ToString%2A> method that displays the names and values of public properties and fields.</span></span> <span data-ttu-id="02978-180">Метод `ToString` возвращает строку в следующем формате:</span><span class="sxs-lookup"><span data-stu-id="02978-180">The `ToString` method returns a string of the following format:</span></span>

> <span data-ttu-id="02978-181">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span><span class="sxs-lookup"><span data-stu-id="02978-181">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span></span>

<span data-ttu-id="02978-182">Для ссылочных типов вместо значения свойства отображается имя типа того объекта, на который ссылается это свойство.</span><span class="sxs-lookup"><span data-stu-id="02978-182">For reference types, the type name of the object that the property refers to is displayed instead of the property value.</span></span> <span data-ttu-id="02978-183">В следующем примере массив имеет ссылочный тип, поэтому отображается `System.String[]` вместо фактических значений элементов массива:</span><span class="sxs-lookup"><span data-stu-id="02978-183">In the following example, the array is a reference type, so `System.String[]` is displayed instead of the actual array element values:</span></span>

```
Person { FirstName = Nancy, LastName = Davolio, ChildNames = System.String[] }
```

<span data-ttu-id="02978-184">Дополнительные сведения см. в разделе [Встроенное форматирование](../language-reference/builtin-types/record.md#built-in-formatting-for-display) статьи, посвященной записям, в справочнике по языку C#.</span><span class="sxs-lookup"><span data-stu-id="02978-184">For more information, see [Built-in formatting](../language-reference/builtin-types/record.md#built-in-formatting-for-display) in the C# language reference article about records.</span></span>

### <a name="inheritance"></a><span data-ttu-id="02978-185">Наследование</span><span class="sxs-lookup"><span data-stu-id="02978-185">Inheritance</span></span>

<span data-ttu-id="02978-186">Запись может наследовать от другой записи.</span><span class="sxs-lookup"><span data-stu-id="02978-186">A record can inherit from another record.</span></span> <span data-ttu-id="02978-187">Но запись не может наследовать от класса, а класс не может наследовать от записи.</span><span class="sxs-lookup"><span data-stu-id="02978-187">However, a record can't inherit from a class, and a class can't inherit from a record.</span></span>

<span data-ttu-id="02978-188">Следующий пример демонстрирует наследование с использованием синтаксиса позиционных свойств:</span><span class="sxs-lookup"><span data-stu-id="02978-188">The following example illustrates inheritance with positional property syntax:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="PositionalInheritance":::

<span data-ttu-id="02978-189">Чтобы две переменные записи считались равными, у них должен совпадать тип времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="02978-189">For two record variables to be equal, the run-time type must be equal.</span></span> <span data-ttu-id="02978-190">При этом типы содержащихся в них переменных могут отличаться.</span><span class="sxs-lookup"><span data-stu-id="02978-190">The types of the containing variables might be different.</span></span> <span data-ttu-id="02978-191">Это демонстрируется в следующем примере кода:</span><span class="sxs-lookup"><span data-stu-id="02978-191">This is illustrated in the following code example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="InheritanceEquality":::

<span data-ttu-id="02978-192">В этом примере все экземпляры имеют одинаковые свойства и одинаковые значения этих свойств.</span><span class="sxs-lookup"><span data-stu-id="02978-192">In the example, all instances have the same properties and the same property values.</span></span> <span data-ttu-id="02978-193">Но выражение `student == teacher` дает значение `False`, хотя обе переменные имеют тип `Person`.</span><span class="sxs-lookup"><span data-stu-id="02978-193">But `student == teacher` returns `False` although both are `Person`-type variables.</span></span> <span data-ttu-id="02978-194">При этом выражение `student == student2` дает значение `True`, хотя одна из переменных имеет тип `Person`, а другая — `Student`.</span><span class="sxs-lookup"><span data-stu-id="02978-194">And `student == student2` returns `True` although one is a `Person` variable and one is a `Student` variable.</span></span>

<span data-ttu-id="02978-195">В выходные данные `ToString` включаются все свойства и поля с атрибутом public, как в производных, так и базовых типах, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="02978-195">All public properties and fields of both derived and base types are included in the `ToString` output, as shown in the following example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="ToStringInheritance":::

<span data-ttu-id="02978-196">Дополнительные сведения см. в разделе [Наследование](../language-reference/builtin-types/record.md#inheritance) статьи, посвященной записям, в справочнике по языку C#.</span><span class="sxs-lookup"><span data-stu-id="02978-196">For more information, see [Inheritance](../language-reference/builtin-types/record.md#inheritance) in the C# language reference article about records.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="02978-197">Методы задания только инициализации</span><span class="sxs-lookup"><span data-stu-id="02978-197">Init only setters</span></span>

<span data-ttu-id="02978-198">***Методы задания только для инициализации*** обеспечивают единообразный синтаксис для инициализации членов объекта.</span><span class="sxs-lookup"><span data-stu-id="02978-198">***Init only setters*** provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="02978-199">Инициализаторы свойств позволяют ясно понять, какое значение задает то или иное свойство.</span><span class="sxs-lookup"><span data-stu-id="02978-199">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="02978-200">Недостаток заключается в том, что эти свойства должны быть устанавливаемыми.</span><span class="sxs-lookup"><span data-stu-id="02978-200">The downside is that those properties must be settable.</span></span> <span data-ttu-id="02978-201">Начиная с C# 9.0, для свойств и индексаторов можно создавать методы доступа `init`, а не методы доступа `set`.</span><span class="sxs-lookup"><span data-stu-id="02978-201">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="02978-202">Вызывающие объекты могут использовать синтаксис инициализатора свойств для установки этих значений в выражениях создания, но после завершения конструирования эти свойства будут доступны только для чтения.</span><span class="sxs-lookup"><span data-stu-id="02978-202">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="02978-203">Методы задания только для инициализации предоставляют окно для изменения состояния.</span><span class="sxs-lookup"><span data-stu-id="02978-203">Init only setters provide a window to change state.</span></span> <span data-ttu-id="02978-204">Это окно закрывается, когда завершается этап конструирования.</span><span class="sxs-lookup"><span data-stu-id="02978-204">That window closes when the construction phase ends.</span></span> <span data-ttu-id="02978-205">Этап конструирования фактически завершается после всех инициализаций, включая инициализаторы свойств и выражения with.</span><span class="sxs-lookup"><span data-stu-id="02978-205">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="02978-206">Можно объявить методы задания только для инициализации (`init`) в любом написанном вами типе.</span><span class="sxs-lookup"><span data-stu-id="02978-206">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="02978-207">Ниже приведен пример определения структуры наблюдения за погодой.</span><span class="sxs-lookup"><span data-stu-id="02978-207">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="02978-208">Вызывающие объекты могут использовать синтаксис инициализатора свойств для установки значений, сохраняя при этом неизменность.</span><span class="sxs-lookup"><span data-stu-id="02978-208">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="02978-209">Попытка изменить наблюдение после инициализации приведет к ошибке компилятора:</span><span class="sxs-lookup"><span data-stu-id="02978-209">An attempt to change an observation after initialization results in a compiler error:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="02978-210">Методы задания только для инициализации могут быть полезны для задания свойств базового класса из производных классов.</span><span class="sxs-lookup"><span data-stu-id="02978-210">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="02978-211">Они также могут устанавливать производные свойства через вспомогательные методы в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="02978-211">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="02978-212">В позиционных записях свойства объявляются с помощью методов задания только для инициализации.</span><span class="sxs-lookup"><span data-stu-id="02978-212">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="02978-213">Эти методы задания используются в выражениях with.</span><span class="sxs-lookup"><span data-stu-id="02978-213">Those setters are used in with-expressions.</span></span> <span data-ttu-id="02978-214">Методы задания только для инициализации можно объявить для любых создаваемых вами `class`, `struct` или `record`.</span><span class="sxs-lookup"><span data-stu-id="02978-214">You can declare init only setters for any `class`, `struct`, or `record` you define.</span></span>

<span data-ttu-id="02978-215">Дополнительные сведения см. в разделе, посвященном ключевому слову [init (справочник по C#)](../language-reference/keywords/init.md).</span><span class="sxs-lookup"><span data-stu-id="02978-215">For more information, see [init (C# Reference)](../language-reference/keywords/init.md).</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="02978-216">Инструкции верхнего уровня</span><span class="sxs-lookup"><span data-stu-id="02978-216">Top-level statements</span></span>

<span data-ttu-id="02978-217">***Инструкции верхнего уровня*** избавляют от ненужных формальностей во многих приложениях.</span><span class="sxs-lookup"><span data-stu-id="02978-217">***Top-level statements*** remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="02978-218">Рассмотрим каноническую программу Hello World!.</span><span class="sxs-lookup"><span data-stu-id="02978-218">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="02978-219">.</span><span class="sxs-lookup"><span data-stu-id="02978-219">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="02978-220">Здесь только одна строка кода, которая что-то делает.</span><span class="sxs-lookup"><span data-stu-id="02978-220">There's only one line of code that does anything.</span></span> <span data-ttu-id="02978-221">С помощью инструкций верхнего уровня можно заменить весь этот шаблон директивой `using` и одной строкой, которая делает всю работу:</span><span class="sxs-lookup"><span data-stu-id="02978-221">With top-level statements, you can replace all that boilerplate with the `using` directive and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="02978-222">Если требуется однострочная программа, можно удалить директиву `using` и использовать полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="02978-222">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="02978-223">Только один файл в приложении может использовать инструкции верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="02978-223">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="02978-224">Если компилятор обнаруживает операторы верхнего уровня в нескольких исходных файлах, это приводит к ошибке.</span><span class="sxs-lookup"><span data-stu-id="02978-224">If the compiler finds top-level statements in multiple source files, it's an error.</span></span> <span data-ttu-id="02978-225">Ошибка также возникает, если объединить операторы верхнего уровня с объявленным методом точки входа программы (как правило, это метод `Main`).</span><span class="sxs-lookup"><span data-stu-id="02978-225">It's also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="02978-226">В определенном смысле можно сказать, что один файл содержит инструкции, которые обычно находятся в методе `Main` класса `Program`.</span><span class="sxs-lookup"><span data-stu-id="02978-226">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="02978-227">Одним из наиболее распространенных применений этой функции является создание обучающих материалов.</span><span class="sxs-lookup"><span data-stu-id="02978-227">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="02978-228">Начинающие разработчики на языке C# могут написать каноническую программу Hello World!</span><span class="sxs-lookup"><span data-stu-id="02978-228">Beginner C# developers can write the canonical "Hello World!"</span></span> <span data-ttu-id="02978-229">в одной-двух строках кода.</span><span class="sxs-lookup"><span data-stu-id="02978-229">in one or two lines of code.</span></span> <span data-ttu-id="02978-230">Никакие дополнительные формальности не требуются.</span><span class="sxs-lookup"><span data-stu-id="02978-230">None of the extra ceremony is needed.</span></span> <span data-ttu-id="02978-231">Но и опытные разработчики также найдут много применений для этой функции.</span><span class="sxs-lookup"><span data-stu-id="02978-231">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="02978-232">Инструкции верхнего уровня позволяют экспериментировать в стиле написания сценариев, аналогично записным книжкам Jupyter.</span><span class="sxs-lookup"><span data-stu-id="02978-232">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="02978-233">Инструкции верхнего уровня отлично подходят для небольших консольных и служебных программ.</span><span class="sxs-lookup"><span data-stu-id="02978-233">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="02978-234">[Функции Azure](/azure/azure-functions/) являются идеальным примером использования операторов верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="02978-234">[Azure Functions](/azure/azure-functions/) is an ideal use case for top-level statements.</span></span>

<span data-ttu-id="02978-235">Что важнее всего, инструкции верхнего уровня не ограничивают область применения или сложность приложения.</span><span class="sxs-lookup"><span data-stu-id="02978-235">Most importantly, top-level statements don't limit your application's scope or complexity.</span></span> <span data-ttu-id="02978-236">Эти инструкции могут обращаться к любому классу .NET и использовать его.</span><span class="sxs-lookup"><span data-stu-id="02978-236">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="02978-237">Они также не ограничивают использование аргументов командной строки и возвращаемых значений.</span><span class="sxs-lookup"><span data-stu-id="02978-237">They also don't limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="02978-238">Инструкции верхнего уровня могут обращаться к массиву строк с именем `args`.</span><span class="sxs-lookup"><span data-stu-id="02978-238">Top-level statements can access an array of strings named `args`.</span></span> <span data-ttu-id="02978-239">Если инструкции верхнего уровня возвращают целочисленное значение, это значение преобразуется в целочисленный код возврата из синтезированного метода `Main`.</span><span class="sxs-lookup"><span data-stu-id="02978-239">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="02978-240">Инструкции верхнего уровня могут содержать асинхронные выражения.</span><span class="sxs-lookup"><span data-stu-id="02978-240">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="02978-241">В этом случае синтезированная точка входа возвращает `Task` или `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="02978-241">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

<span data-ttu-id="02978-242">Дополнительные сведения см. в статье [Инструкции верхнего уровня](../programming-guide/main-and-command-args/top-level-statements.md) руководства по программированию на C#.</span><span class="sxs-lookup"><span data-stu-id="02978-242">For more information, see [Top-level statements](../programming-guide/main-and-command-args/top-level-statements.md) in the C# Programming Guide.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="02978-243">Улучшения сопоставления шаблонов</span><span class="sxs-lookup"><span data-stu-id="02978-243">Pattern matching enhancements</span></span>

<span data-ttu-id="02978-244">C# 9 включает новые улучшения сопоставления шаблонов.</span><span class="sxs-lookup"><span data-stu-id="02978-244">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="02978-245">***Шаблоны типов*** проверяют соответствие переменной определенному типу.</span><span class="sxs-lookup"><span data-stu-id="02978-245">***Type patterns*** match a variable is a type</span></span>
- <span data-ttu-id="02978-246">***Шаблоны в круглых скобках*** усиливают или подчеркивают приоритет сочетаний шаблонов.</span><span class="sxs-lookup"><span data-stu-id="02978-246">***Parenthesized patterns*** enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="02978-247">***В шаблонах конъюнкций `and`*** требуется соответствие обоих шаблонов.</span><span class="sxs-lookup"><span data-stu-id="02978-247">***Conjunctive `and` patterns*** require both patterns to match</span></span>
- <span data-ttu-id="02978-248">***В шаблонах дизъюнкций `or`*** требуется соответствие хотя бы одного из шаблонов.</span><span class="sxs-lookup"><span data-stu-id="02978-248">***Disjunctive `or` patterns*** require either pattern to match</span></span>
- <span data-ttu-id="02978-249">В ***шаблонах `not` с отрицанием*** требуется несоответствие данного шаблона.</span><span class="sxs-lookup"><span data-stu-id="02978-249">***Negated `not` patterns*** require that a pattern doesn't match</span></span>
- <span data-ttu-id="02978-250">***В шаблонах сравнения*** требуется, чтобы входные данные были меньше, больше, меньше или равны, больше или равны данной константе.</span><span class="sxs-lookup"><span data-stu-id="02978-250">***Relational patterns*** require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="02978-251">Эти шаблоны обогащают синтаксис шаблонов.</span><span class="sxs-lookup"><span data-stu-id="02978-251">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="02978-252">Рассмотрим следующие примеры.</span><span class="sxs-lookup"><span data-stu-id="02978-252">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="02978-253">С помощью дополнительных скобок можно явно указать, что `and` имеет более высокий приоритет, чем `or`.</span><span class="sxs-lookup"><span data-stu-id="02978-253">With optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="02978-254">Одним из наиболее распространенных применений нового синтаксиса является проверка значения на null.</span><span class="sxs-lookup"><span data-stu-id="02978-254">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="02978-255">Любой из этих шаблонов можно использовать в любом контексте, где разрешены шаблоны: выражения с шаблоном `is`, выражения `switch`, вложенные шаблоны и шаблоны метки `case` оператора `switch`.</span><span class="sxs-lookup"><span data-stu-id="02978-255">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement's `case` label.</span></span>

<span data-ttu-id="02978-256">Дополнительные сведения см. в разделе [Шаблоны (справочник по C#)](../language-reference/operators/patterns.md).</span><span class="sxs-lookup"><span data-stu-id="02978-256">For more information, see [Patterns (C# reference)](../language-reference/operators/patterns.md).</span></span>

<span data-ttu-id="02978-257">Дополнительные сведения см. в разделах [Реляционные шаблоны](../language-reference/operators/patterns.md#relational-patterns) и [Логические шаблоны](../language-reference/operators/patterns.md#logical-patterns) статьи [Шаблоны](../language-reference/operators/patterns.md).</span><span class="sxs-lookup"><span data-stu-id="02978-257">For more information, see the [Relational patterns](../language-reference/operators/patterns.md#relational-patterns) and [Logical patterns](../language-reference/operators/patterns.md#logical-patterns) sections of the [Patterns](../language-reference/operators/patterns.md) article.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="02978-258">Производительность и взаимодействие</span><span class="sxs-lookup"><span data-stu-id="02978-258">Performance and interop</span></span>

<span data-ttu-id="02978-259">Три новых функции улучшают поддержку собственного взаимодействия и низкоуровневых библиотек, требующих высокой производительности: целые числа собственного размера, указатели функций и пропуск флага `localsinit`.</span><span class="sxs-lookup"><span data-stu-id="02978-259">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="02978-260">Целые числа собственного размера `nint` и `nuint` являются целочисленными типами.</span><span class="sxs-lookup"><span data-stu-id="02978-260">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="02978-261">Они выражаются базовыми типами <xref:System.IntPtr?displayProperty=nameWithType> и <xref:System.UIntPtr?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="02978-261">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="02978-262">Компилятор предоставляет дополнительные преобразования и операции для этих типов в качестве собственных целых чисел.</span><span class="sxs-lookup"><span data-stu-id="02978-262">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="02978-263">Целые числа собственного размера определяют свойства для `MaxValue` или `MinValue`.</span><span class="sxs-lookup"><span data-stu-id="02978-263">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="02978-264">Такие значения не могут быть выражены как константы времени компиляции, так как они зависят от собственного размера целого числа на целевом компьютере.</span><span class="sxs-lookup"><span data-stu-id="02978-264">These values can't be expressed as compile-time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="02978-265">Во время выполнения эти значения доступны только для чтения.</span><span class="sxs-lookup"><span data-stu-id="02978-265">Those values are readonly at runtime.</span></span> <span data-ttu-id="02978-266">Для `nint` можно использовать значения констант в диапазоне [`int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="02978-266">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="02978-267">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="02978-267">`int.MaxValue`].</span></span> <span data-ttu-id="02978-268">Для `nuint` можно использовать значения констант в диапазоне [`uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="02978-268">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="02978-269">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="02978-269">`uint.MaxValue`].</span></span> <span data-ttu-id="02978-270">Компилятор выполняет сворачивание константы для всех унарных и бинарных операторов, используя типы <xref:System.Int32?displayProperty=nameWithType> и <xref:System.UInt32?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="02978-270">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="02978-271">Если результат не помещается в 32 бит, операция выполняется во время выполнения и не считается константой.</span><span class="sxs-lookup"><span data-stu-id="02978-271">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="02978-272">Целые числа собственного размера могут повысить производительность в сценариях с большим количеством целочисленных вычислений, в которых необходимо обеспечить максимально высокую производительность.</span><span class="sxs-lookup"><span data-stu-id="02978-272">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span> <span data-ttu-id="02978-273">Дополнительные сведения см. в статье о [типах `nint` и `nuint`](../language-reference/builtin-types/nint-nuint.md).</span><span class="sxs-lookup"><span data-stu-id="02978-273">For more information, see [`nint` and `nuint` types](../language-reference/builtin-types/nint-nuint.md)</span></span>

<span data-ttu-id="02978-274">Указатели функций предоставляют простой синтаксис для доступа к кодам операций IL `ldftn` и `calli`.</span><span class="sxs-lookup"><span data-stu-id="02978-274">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="02978-275">Указатели функций можно объявлять с помощью нового синтаксиса `delegate*`.</span><span class="sxs-lookup"><span data-stu-id="02978-275">You can declare function pointers using new `delegate*` syntax.</span></span> <span data-ttu-id="02978-276">Тип `delegate*` — это тип указателя.</span><span class="sxs-lookup"><span data-stu-id="02978-276">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="02978-277">При вызове типа `delegate*` используется `calli`, в отличие от делегата, который использует `callvirt` в методе `Invoke()`.</span><span class="sxs-lookup"><span data-stu-id="02978-277">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="02978-278">Синтаксически вызовы являются идентичными.</span><span class="sxs-lookup"><span data-stu-id="02978-278">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="02978-279">При вызове указателя функции используется соглашение о вызовах `managed`.</span><span class="sxs-lookup"><span data-stu-id="02978-279">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="02978-280">Если требуется объявить о соглашении о вызовах `unmanaged`, добавьте ключевое слово `unmanaged` после синтаксиса `delegate*`.</span><span class="sxs-lookup"><span data-stu-id="02978-280">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="02978-281">Другие соглашения о вызовах можно указать с помощью атрибутов в объявлении `delegate*`.</span><span class="sxs-lookup"><span data-stu-id="02978-281">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span> <span data-ttu-id="02978-282">Дополнительные сведения см. в разделе [Небезопасный код и типы указателей](../language-reference/unsafe-code.md).</span><span class="sxs-lookup"><span data-stu-id="02978-282">For more information, see [Unsafe code and pointer types](../language-reference/unsafe-code.md).</span></span>

<span data-ttu-id="02978-283">Наконец, можно добавить атрибут <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType>, чтобы компилятор не создавал флаг `localsinit`.</span><span class="sxs-lookup"><span data-stu-id="02978-283">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="02978-284">Этот флаг указывает среде CLR на нулевую инициализацию всех локальных переменных.</span><span class="sxs-lookup"><span data-stu-id="02978-284">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="02978-285">Флаг `localsinit` используется в C# по умолчанию, начиная с версии 1.0.</span><span class="sxs-lookup"><span data-stu-id="02978-285">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="02978-286">Однако при использовании дополнительной нулевой инициализации в некоторых сценариях может снизиться производительность.</span><span class="sxs-lookup"><span data-stu-id="02978-286">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="02978-287">В частности, при использовании `stackalloc`.</span><span class="sxs-lookup"><span data-stu-id="02978-287">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="02978-288">В таких случаях можно добавить атрибут <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span><span class="sxs-lookup"><span data-stu-id="02978-288">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="02978-289">Его можно добавить в один метод или свойство, в `class`, `struct`, `interface` или даже в модуль.</span><span class="sxs-lookup"><span data-stu-id="02978-289">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="02978-290">Этот атрибут не влияет на методы `abstract`. Он влияет на код, созданный для реализации.</span><span class="sxs-lookup"><span data-stu-id="02978-290">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span> <span data-ttu-id="02978-291">Дополнительные сведения см. в разделе об [атрибуте](../language-reference/attributes/general.md#skiplocalsinit-attribute) `SkipLocalsInit`.</span><span class="sxs-lookup"><span data-stu-id="02978-291">For more information, see [`SkipLocalsInit` attribute](../language-reference/attributes/general.md#skiplocalsinit-attribute).</span></span>

<span data-ttu-id="02978-292">Эти функции могут повысить производительность в некоторых сценариях.</span><span class="sxs-lookup"><span data-stu-id="02978-292">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="02978-293">Их следует использовать только после тщательного тестирования как до, так и после внедрения.</span><span class="sxs-lookup"><span data-stu-id="02978-293">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="02978-294">Код, включающий целые числа собственного размера, нужно тестировать на нескольких целевых платформах с различными размерами целых чисел.</span><span class="sxs-lookup"><span data-stu-id="02978-294">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="02978-295">Другие функции требуют небезопасный код.</span><span class="sxs-lookup"><span data-stu-id="02978-295">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="02978-296">Функции подбора и завершения</span><span class="sxs-lookup"><span data-stu-id="02978-296">Fit and finish features</span></span>

<span data-ttu-id="02978-297">Многие другие функции позволяют более эффективно писать код.</span><span class="sxs-lookup"><span data-stu-id="02978-297">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="02978-298">В C# 9.0 можно опустить тип в [выражении `new`](../language-reference/operators/new-operator.md), если тип созданного объекта уже известен.</span><span class="sxs-lookup"><span data-stu-id="02978-298">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="02978-299">Наиболее часто это используется в объявлениях полей.</span><span class="sxs-lookup"><span data-stu-id="02978-299">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="02978-300">`new` с целевым типом можно также использовать, если необходимо создать объект для передачи его в качестве аргумента в метод.</span><span class="sxs-lookup"><span data-stu-id="02978-300">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="02978-301">Рассмотрим метод `ForecastFor()` со следующей сигнатурой.</span><span class="sxs-lookup"><span data-stu-id="02978-301">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="02978-302">Его можно вызвать следующим образом.</span><span class="sxs-lookup"><span data-stu-id="02978-302">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="02978-303">Еще один полезный способ использовать эту функцию — объединить ее со свойствами только для инициализации при инициализации нового объекта.</span><span class="sxs-lookup"><span data-stu-id="02978-303">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="02978-304">Экземпляр, созданный конструктором по умолчанию, можно вернуть с помощью инструкции `return new();`.</span><span class="sxs-lookup"><span data-stu-id="02978-304">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="02978-305">Аналогичная функция улучшает разрешение целевого типа в [условных выражениях](../language-reference/operators/conditional-operator.md).</span><span class="sxs-lookup"><span data-stu-id="02978-305">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="02978-306">Благодаря такому изменению два выражения необязательно должны иметь неявное преобразование из одного в другое, но оба могут иметь неявные преобразования в целевой тип.</span><span class="sxs-lookup"><span data-stu-id="02978-306">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="02978-307">Скорее всего, вы не заметите этого изменения.</span><span class="sxs-lookup"><span data-stu-id="02978-307">You likely won't notice this change.</span></span> <span data-ttu-id="02978-308">Обратите внимание, что некоторые условные выражения, которые ранее требовали приведения или не компилировались, теперь просто начнут работать.</span><span class="sxs-lookup"><span data-stu-id="02978-308">What you will notice is that some conditional expressions that previously required casts or wouldn't compile now just work.</span></span>

<span data-ttu-id="02978-309">Начиная с C# 9.0, можно добавлять модификатор `static` в [лямбда-выражения](../language-reference/operators/lambda-expressions.md) или [анонимные методы](../language-reference/operators/delegate-operator.md).</span><span class="sxs-lookup"><span data-stu-id="02978-309">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="02978-310">Статические лямбда-выражения аналогичны локальным функциям с модификатором `static`: статические лямбда-выражения и анонимные методы не могут захватывать локальные переменные и состояние экземпляра.</span><span class="sxs-lookup"><span data-stu-id="02978-310">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="02978-311">Модификатор `static` предотвращает случайное захватывание других переменных.</span><span class="sxs-lookup"><span data-stu-id="02978-311">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="02978-312">Ковариантные возвращаемые типы обеспечивают гибкость для типов возвращаемых значений методов [переопределения](../language-reference/keywords/override.md).</span><span class="sxs-lookup"><span data-stu-id="02978-312">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="02978-313">Метод переопределения может возвращать тип, производный от типа возвращаемых значений переопределенного базового метода.</span><span class="sxs-lookup"><span data-stu-id="02978-313">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="02978-314">Это может быть полезно для записей и для других типов, которые поддерживают виртуальные методы клонирования или фабричные методы.</span><span class="sxs-lookup"><span data-stu-id="02978-314">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="02978-315">Кроме того, [цикл `foreach`](../language-reference/keywords/foreach-in.md) будет распознавать и использовать метод расширения `GetEnumerator`, который в противном случае удовлетворяет шаблону `foreach`.</span><span class="sxs-lookup"><span data-stu-id="02978-315">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="02978-316">Это изменение означает, что `foreach` согласуется с другими конструкциями на основе шаблонов, такими как асинхронная модель и деконструирование на основе шаблона.</span><span class="sxs-lookup"><span data-stu-id="02978-316">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="02978-317">На практике это изменение означает, что можно добавить поддержку `foreach` в любой тип.</span><span class="sxs-lookup"><span data-stu-id="02978-317">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="02978-318">При перечислении объектов имеет смысл ограничить его использование.</span><span class="sxs-lookup"><span data-stu-id="02978-318">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="02978-319">Кроме того, можно использовать пустые переменные в качестве параметров для лямбда-выражений.</span><span class="sxs-lookup"><span data-stu-id="02978-319">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="02978-320">Это удобное изменение позволяет избежать присвоения имени аргументу, а компилятор может избежать его использования.</span><span class="sxs-lookup"><span data-stu-id="02978-320">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="02978-321">Для любого аргумента используется символ `_`.</span><span class="sxs-lookup"><span data-stu-id="02978-321">You use the `_` for any argument.</span></span> <span data-ttu-id="02978-322">Дополнительные сведения см. в разделе [Входные параметры лямбда-выражения](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) статьи о [лямбда-выражениях](../language-reference/operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="02978-322">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="02978-323">Наконец, теперь можно применять атрибуты к [локальным функциям](../programming-guide/classes-and-structs/local-functions.md).</span><span class="sxs-lookup"><span data-stu-id="02978-323">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="02978-324">Например, к локальным функциям можно применить [заметки атрибутов, допускающих значение null](../language-reference/attributes/nullable-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="02978-324">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="02978-325">Поддержка генераторов кода</span><span class="sxs-lookup"><span data-stu-id="02978-325">Support for code generators</span></span>

<span data-ttu-id="02978-326">Две заключительные функции обеспечивают поддержку генераторов кода в C#.</span><span class="sxs-lookup"><span data-stu-id="02978-326">Two final features support C# code generators.</span></span> <span data-ttu-id="02978-327">Генераторы кода C# — это компонент, который вы можете написать подобно анализатору или исправлению кода Roslyn.</span><span class="sxs-lookup"><span data-stu-id="02978-327">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="02978-328">Разница заключается в том, что генераторы кода анализируют код и пишут новые файлы исходного кода в рамках процесса компиляции.</span><span class="sxs-lookup"><span data-stu-id="02978-328">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="02978-329">Типичный генератор кода ищет в коде атрибуты или другие соглашения.</span><span class="sxs-lookup"><span data-stu-id="02978-329">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="02978-330">Генератор кода считывает атрибуты или другие элементы кода с помощью анализирующих интерфейсов API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="02978-330">A code generator reads attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="02978-331">На основе этой информации он добавляет новый код в компиляцию.</span><span class="sxs-lookup"><span data-stu-id="02978-331">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="02978-332">Генераторы исходного кода могут только добавлять код, они не могут изменять существующий код в компиляции.</span><span class="sxs-lookup"><span data-stu-id="02978-332">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="02978-333">Этими двумя функциями, добавленными для поддержки генераторов кода, являются расширения для ***синтаксиса разделяемого метода** _ и _*_инициализаторов модулей_\*\*.</span><span class="sxs-lookup"><span data-stu-id="02978-333">The two features added for code generators are extensions to ***partial method syntax** _, and _*_module initializers_\*\*.</span></span> <span data-ttu-id="02978-334">Сначала рассмотрим изменения в разделяемые методы.</span><span class="sxs-lookup"><span data-stu-id="02978-334">First, the changes to partial methods.</span></span> <span data-ttu-id="02978-335">До C# 9.0 разделяемые методы были `private`, но не могли иметь модификаторов доступа, иметь возвращаемое значение `void` и параметры `out`.</span><span class="sxs-lookup"><span data-stu-id="02978-335">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="02978-336">Эти ограничения подразумевают, что, если реализация метода не предоставлена, компилятор удаляет все вызовы к разделяемому методу.</span><span class="sxs-lookup"><span data-stu-id="02978-336">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="02978-337">В C# 9.0 эти ограничения снимаются, но требуется, чтобы объявления разделяемых методов имели реализацию.</span><span class="sxs-lookup"><span data-stu-id="02978-337">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="02978-338">Генераторы кода могут предоставить такую реализацию.</span><span class="sxs-lookup"><span data-stu-id="02978-338">Code generators can provide that implementation.</span></span> <span data-ttu-id="02978-339">Чтобы избежать критических изменений, компилятор рассматривает любой разделяемый метод без модификатора доступа как метод, следующий старым правилам.</span><span class="sxs-lookup"><span data-stu-id="02978-339">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="02978-340">Если разделяемый метод включает модификатор доступа `private`, этот разделяемый метод обрабатывается в соответствии с новыми правилами.</span><span class="sxs-lookup"><span data-stu-id="02978-340">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span> <span data-ttu-id="02978-341">Дополнительные сведения см. в разделе о [разделяемом методе (Справочник по C#)](../language-reference/keywords/partial-method.md).</span><span class="sxs-lookup"><span data-stu-id="02978-341">For more information, see [partial method (C# Reference)](../language-reference/keywords/partial-method.md).</span></span>

<span data-ttu-id="02978-342">Второй новой функцией для генераторов кода являются ***инициализаторы модулей***.</span><span class="sxs-lookup"><span data-stu-id="02978-342">The second new feature for code generators is ***module initializers***.</span></span> <span data-ttu-id="02978-343">Инициализаторы модулей — это методы, к которым прикреплен атрибут <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute>.</span><span class="sxs-lookup"><span data-stu-id="02978-343">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="02978-344">Эти методы будут вызываться средой выполнения до доступа к полю или вызова метода в целом модуле.</span><span class="sxs-lookup"><span data-stu-id="02978-344">These methods will be called by the runtime before any other field access or method invocation within the entire module.</span></span> <span data-ttu-id="02978-345">Метод инициализатора модуля:</span><span class="sxs-lookup"><span data-stu-id="02978-345">A module initializer method:</span></span>

- <span data-ttu-id="02978-346">должен быть статическим;</span><span class="sxs-lookup"><span data-stu-id="02978-346">Must be static</span></span>
- <span data-ttu-id="02978-347">должен быть без параметров;</span><span class="sxs-lookup"><span data-stu-id="02978-347">Must be parameterless</span></span>
- <span data-ttu-id="02978-348">должен возвращать значение void;</span><span class="sxs-lookup"><span data-stu-id="02978-348">Must return void</span></span>
- <span data-ttu-id="02978-349">не должен быть универсальным методом;</span><span class="sxs-lookup"><span data-stu-id="02978-349">Must not be a generic method</span></span>
- <span data-ttu-id="02978-350">не должен содержаться в универсальном классе;</span><span class="sxs-lookup"><span data-stu-id="02978-350">Must not be contained in a generic class</span></span>
- <span data-ttu-id="02978-351">должен быть доступен из содержащего модуля.</span><span class="sxs-lookup"><span data-stu-id="02978-351">Must be accessible from the containing module</span></span>

<span data-ttu-id="02978-352">Последний пункт фактически означает, что метод и содержащий его класс должны быть внутренними или открытыми.</span><span class="sxs-lookup"><span data-stu-id="02978-352">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="02978-353">Метод не может быть локальной функцией.</span><span class="sxs-lookup"><span data-stu-id="02978-353">The method can't be a local function.</span></span> <span data-ttu-id="02978-354">Дополнительные сведения см. в разделе об [атрибуте](../language-reference/attributes/general.md#moduleinitializer-attribute) `ModuleInitializer`.</span><span class="sxs-lookup"><span data-stu-id="02978-354">For more information, see [`ModuleInitializer` attribute](../language-reference/attributes/general.md#moduleinitializer-attribute).</span></span>
