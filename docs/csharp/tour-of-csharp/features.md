---
title: Обзор C# — основные области языка
description: Вы еще не знакомы с C#? Изучите основы этого языка. В этой статье содержится обзор основных особенностей языка.
ms.date: 08/06/2020
ms.openlocfilehash: 943701b544dd3495fa2286e804e2566da146cb45
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216659"
---
# <a name="major-language-areas"></a><span data-ttu-id="23715-105">Основные области языка</span><span class="sxs-lookup"><span data-stu-id="23715-105">Major language areas</span></span>

## <a name="arrays-collections-and-linq"></a><span data-ttu-id="23715-106">Массивы, коллекции и LINQ</span><span class="sxs-lookup"><span data-stu-id="23715-106">Arrays, collections, and LINQ</span></span>

<span data-ttu-id="23715-107">В C# и .NET имеется множество различных типов коллекций.</span><span class="sxs-lookup"><span data-stu-id="23715-107">C# and .NET provide many different collection types.</span></span> <span data-ttu-id="23715-108">Синтаксис массивов определяется языком.</span><span class="sxs-lookup"><span data-stu-id="23715-108">Arrays have syntax defined by the language.</span></span> <span data-ttu-id="23715-109">Универсальные типы коллекций перечислены в пространстве имен <xref:System.Collections.Generic?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="23715-109">Generic collection types are listed in the <xref:System.Collections.Generic?displayProperty=fullName> namespace.</span></span> <span data-ttu-id="23715-110">К специализированным коллекциям относятся <xref:System.Span%601?displayProperty=nameWithType> для доступа к непрерывной памяти в кадре стека и <xref:System.Memory%601?displayProperty=nameWithType> для доступа к непрерывной памяти в управляемой куче.</span><span class="sxs-lookup"><span data-stu-id="23715-110">Specialized collections include <xref:System.Span%601?displayProperty=nameWithType> for accessing continuous memory on the stack frame, and <xref:System.Memory%601?displayProperty=nameWithType> for accessing continuous memory on the managed heap.</span></span> <span data-ttu-id="23715-111">Все коллекции, включая массивы, <xref:System.Span%601> и <xref:System.Memory%601>, используют общий принцип итерации.</span><span class="sxs-lookup"><span data-stu-id="23715-111">All collections, including arrays, <xref:System.Span%601>, and <xref:System.Memory%601> share a unifying principle for iteration.</span></span> <span data-ttu-id="23715-112">Используется интерфейс <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="23715-112">You use the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="23715-113">Этот единый принцип означает, что любой из типов коллекций можно использовать с запросами LINQ или другими алгоритмами.</span><span class="sxs-lookup"><span data-stu-id="23715-113">This unifying principle means that any of the collection types can be used with LINQ queries or other algorithms.</span></span> <span data-ttu-id="23715-114">Методы пишутся с помощью <xref:System.Collections.Generic.IEnumerable%601>, и алгоритмы работают с любой коллекцией.</span><span class="sxs-lookup"><span data-stu-id="23715-114">You write methods using <xref:System.Collections.Generic.IEnumerable%601> and those algorithms work with any collection.</span></span>

### <a name="arrays"></a><span data-ttu-id="23715-115">Массивы</span><span class="sxs-lookup"><span data-stu-id="23715-115">Arrays</span></span>

<span data-ttu-id="23715-116">[\***Массив** _](../programming-guide/arrays/index.md) — это структура данных, содержащая несколько переменных, доступ к которым осуществляется по вычисляемым индексам.</span><span class="sxs-lookup"><span data-stu-id="23715-116">An [\***array** _](../programming-guide/arrays/index.md) is a data structure that contains a number of variables that are accessed through computed indices.</span></span> <span data-ttu-id="23715-117">Все содержащиеся в массиве переменные, также называемые _\*_элементами массива_\*_, относятся к одному типу.</span><span class="sxs-lookup"><span data-stu-id="23715-117">The variables contained in an array, also called the _*_elements_*_ of the array, are all of the same type.</span></span> <span data-ttu-id="23715-118">Он называется _\*_типом элементов_\*_ массива.</span><span class="sxs-lookup"><span data-stu-id="23715-118">This type is called the _*_element type_*_ of the array.</span></span>

<span data-ttu-id="23715-119">Сами массивы имеют ссылочный тип, и объявление переменной массива только выделяет память для ссылки на экземпляр массива.</span><span class="sxs-lookup"><span data-stu-id="23715-119">Array types are reference types, and the declaration of an array variable simply sets aside space for a reference to an array instance.</span></span> <span data-ttu-id="23715-120">Фактические экземпляры массива создаются динамически во время выполнения с помощью оператора `new`.</span><span class="sxs-lookup"><span data-stu-id="23715-120">Actual array instances are created dynamically at runtime using the `new` operator.</span></span> <span data-ttu-id="23715-121">Операция `new` указывает _\*_длину_\*_ нового экземпляра массива, которая остается неизменной в течение всего времени существования этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="23715-121">The `new` operation specifies the _*_length_*_ of the new array instance, which is then fixed for the lifetime of the instance.</span></span> <span data-ttu-id="23715-122">Элементы массива имеют индексы в диапазоне от `0` до `Length - 1`.</span><span class="sxs-lookup"><span data-stu-id="23715-122">The indices of the elements of an array range from `0` to `Length - 1`.</span></span> <span data-ttu-id="23715-123">Оператор `new` автоматически инициализирует все элементы массива значением по умолчанию. Например, для всех числовых типов устанавливается нулевое значение, а для всех ссылочных типов — значение `null`.</span><span class="sxs-lookup"><span data-stu-id="23715-123">The `new` operator automatically initializes the elements of an array to their default value, which, for example, is zero for all numeric types and `null` for all reference types.</span></span>

<span data-ttu-id="23715-124">Следующий пример кода создает массив из `int` элементов, затем инициализирует этот массив и выводит содержимое массива.</span><span class="sxs-lookup"><span data-stu-id="23715-124">The following example creates an array of `int` elements, initializes the array, and prints the contents of the array.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ArraysSample":::

<span data-ttu-id="23715-125">Этот пример создает и использует _\*_одномерный массив_\*_.</span><span class="sxs-lookup"><span data-stu-id="23715-125">This example creates and operates on a _*_single-dimensional array_*_.</span></span> <span data-ttu-id="23715-126">Кроме этого, C# поддерживает _\*_многомерные массивы_\*_.</span><span class="sxs-lookup"><span data-stu-id="23715-126">C# also supports _*_multi-dimensional arrays_*_.</span></span> <span data-ttu-id="23715-127">Число измерений массива, которое именуется _\*_рангом_\*_ для типа массива, всегда на единицу больше числа запятых, включенных в квадратные скобки типа массива.</span><span class="sxs-lookup"><span data-stu-id="23715-127">The number of dimensions of an array type, also known as the _*_rank_*_ of the array type, is one plus the number of commas between the square brackets of the array type.</span></span> <span data-ttu-id="23715-128">Следующий пример кода поочередно создает одномерный, двухмерный и трехмерный массивы.</span><span class="sxs-lookup"><span data-stu-id="23715-128">The following example allocates a single-dimensional, a two-dimensional, and a three-dimensional array, respectively.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DeclareArrays":::

<span data-ttu-id="23715-129">Массив `a1` содержит 10 элементов, массив `a2` — 50 элементов (10 × 5), и наконец `a3` содержит 100 элементов (10 × 5 × 2).</span><span class="sxs-lookup"><span data-stu-id="23715-129">The `a1` array contains 10 elements, the `a2` array contains 50 (10 × 5) elements, and the `a3` array contains 100 (10 × 5 × 2) elements.</span></span>
<span data-ttu-id="23715-130">Элементы массива могут иметь любой тип, в том числе тип массива.</span><span class="sxs-lookup"><span data-stu-id="23715-130">The element type of an array can be any type, including an array type.</span></span> <span data-ttu-id="23715-131">Массив с элементами типа массива иногда называют _\*_массивом массивов_\*_, так как элементы такого массива не обязаны иметь одинаковую длину.</span><span class="sxs-lookup"><span data-stu-id="23715-131">An array with elements of an array type is sometimes called a _*_jagged array_*_ because the lengths of the element arrays don't all have to be the same.</span></span> <span data-ttu-id="23715-132">Следующий пример создает массив массивов `int`.</span><span class="sxs-lookup"><span data-stu-id="23715-132">The following example allocates an array of arrays of `int`:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ArrayOfArrays":::

<span data-ttu-id="23715-133">В первой строке создается массив с тремя элементами, каждый из которых имеет тип `int[]` и начальное значение `null`.</span><span class="sxs-lookup"><span data-stu-id="23715-133">The first line creates an array with three elements, each of type `int[]` and each with an initial value of `null`.</span></span> <span data-ttu-id="23715-134">В следующих строках эти три элемента инициализируются ссылками на отдельные экземпляры массивов различной длины.</span><span class="sxs-lookup"><span data-stu-id="23715-134">The next lines then initialize the three elements with references to individual array instances of varying lengths.</span></span>

<span data-ttu-id="23715-135">Оператор `new` позволяет задать начальные значения элементов массива, используя _\*_инициализатор массива_\*_. Так называется список выражений, записанных между разделителями `{` и `}`.</span><span class="sxs-lookup"><span data-stu-id="23715-135">The `new` operator permits the initial values of the array elements to be specified using an _*_array initializer_*_, which is a list of expressions written between the delimiters `{` and `}`.</span></span> <span data-ttu-id="23715-136">Следующий пример создает и инициализирует массив `int[]` с тремя элементами.</span><span class="sxs-lookup"><span data-stu-id="23715-136">The following example allocates and initializes an `int[]` with three elements.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeArray":::

<span data-ttu-id="23715-137">Длина массива определяется по числу выражений между скобками `{` и `}`.</span><span class="sxs-lookup"><span data-stu-id="23715-137">The length of the array is inferred from the number of expressions between `{` and `}`.</span></span> <span data-ttu-id="23715-138">Инициализацию массива можно сократить, так как тип массива не обязательно объявлять повторно.</span><span class="sxs-lookup"><span data-stu-id="23715-138">Array initialization can be shortened further such that the array type doesn't have to be restated.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeShortened":::

<span data-ttu-id="23715-139">Оба приведенных выше примера дают результат, эквивалентный следующему коду:</span><span class="sxs-lookup"><span data-stu-id="23715-139">Both of the previous examples are equivalent to the following code:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeGenerated":::

<span data-ttu-id="23715-140">Оператор `foreach` можно использовать для перечисления элементов любой коллекции.</span><span class="sxs-lookup"><span data-stu-id="23715-140">The `foreach` statement can be used to enumerate the elements of any collection.</span></span> <span data-ttu-id="23715-141">Следующий код перечисляет массив из предыдущего примера:</span><span class="sxs-lookup"><span data-stu-id="23715-141">The following code enumerates the array from the preceding example:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="EnumerateArray":::

<span data-ttu-id="23715-142">Оператор `foreach` использует интерфейс <xref:System.Collections.Generic.IEnumerable%601>, поэтому может работать с любой коллекцией.</span><span class="sxs-lookup"><span data-stu-id="23715-142">The `foreach` statement uses the <xref:System.Collections.Generic.IEnumerable%601> interface, so can work with any collection.</span></span>

## <a name="string-interpolation"></a><span data-ttu-id="23715-143">Интерполяция строк</span><span class="sxs-lookup"><span data-stu-id="23715-143">String interpolation</span></span>

<span data-ttu-id="23715-144">[_\*_Интерполяция строк_\*_](../language-reference/tokens/interpolated.md) в C# позволяет форматировать строки, определяя выражения, результаты которых помещаются в строку формата.</span><span class="sxs-lookup"><span data-stu-id="23715-144">C# [_*_string interpolation_*_](../language-reference/tokens/interpolated.md) enables you to format strings by defining expressions whose results are placed in a format string.</span></span> <span data-ttu-id="23715-145">Например, в следующем примере выводится температура в указанный день из набора данных о погоде:</span><span class="sxs-lookup"><span data-stu-id="23715-145">For example, the following example prints the temperature on a given day from a set of weather data:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="StringInterpolation":::

<span data-ttu-id="23715-146">Интерполированная строка объявляется с помощью токена `$`.</span><span class="sxs-lookup"><span data-stu-id="23715-146">An interpolated string is declared using the `$` token.</span></span> <span data-ttu-id="23715-147">При интерполяции строк вычисляются выражения между `{` и `}`, результат преобразуется в `string`, а затем текст в квадратных скобках заменяется строковым результатом выражения.</span><span class="sxs-lookup"><span data-stu-id="23715-147">String interpolation evaluates the expressions between `{` and `}`, then converts the result to a `string`, and replaces the text between the brackets with the string result of the expression.</span></span> <span data-ttu-id="23715-148">`:` в первом выражении `{weatherData.Date:MM-DD-YYYY}` указывает _строку формата\*.</span><span class="sxs-lookup"><span data-stu-id="23715-148">The `:` in the first expression, `{weatherData.Date:MM-DD-YYYY}` specifies the _format string\*.</span></span> <span data-ttu-id="23715-149">В предыдущем примере указывается, что дата должна выводиться в формате "ММ-ДД-ГГГГ".</span><span class="sxs-lookup"><span data-stu-id="23715-149">In the preceding example, it specifies that the date should be printed in "MM-DD-YYYY" format.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="23715-150">Регулярные выражения</span><span class="sxs-lookup"><span data-stu-id="23715-150">Pattern matching</span></span>

<span data-ttu-id="23715-151">В языке C# есть выражения [\***сопоставления шаблонов** _](../pattern-matching.md) для запроса состояния объекта и выполнения кода в зависимости этого состояния.</span><span class="sxs-lookup"><span data-stu-id="23715-151">The C# language provides [\***pattern matching** _](../pattern-matching.md) expressions to query the state of an object and execute code based on that state.</span></span> <span data-ttu-id="23715-152">Чтобы определить, какое действие следует предпринять, можно проверить типы и значения свойств и полей.</span><span class="sxs-lookup"><span data-stu-id="23715-152">You can inspect types and the values of properties and fields to determine which action to take.</span></span> <span data-ttu-id="23715-153">Выражение `switch` является основным для сопоставления шаблонов.</span><span class="sxs-lookup"><span data-stu-id="23715-153">The `switch` expression is the primary expression for pattern matching.</span></span>

## <a name="delegates-and-lambda-expressions"></a><span data-ttu-id="23715-154">Делегаты и лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="23715-154">Delegates and lambda expressions</span></span>

<span data-ttu-id="23715-155">[_\*_Тип delegate_\*_](../delegates-overview.md) представляет ссылки на методы с конкретным списком параметров и типом возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="23715-155">A [_*_delegate type_*_](../delegates-overview.md) represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="23715-156">Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="23715-156">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="23715-157">Принцип работы делегатов близок к указателям функций из некоторых языков.</span><span class="sxs-lookup"><span data-stu-id="23715-157">Delegates are similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="23715-158">В отличие от указателей функций, делегаты являются объектно-ориентированными и типобезопасными.</span><span class="sxs-lookup"><span data-stu-id="23715-158">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="23715-159">Следующий пример кода объявляет и использует тип делегата с именем `Function`.</span><span class="sxs-lookup"><span data-stu-id="23715-159">The following example declares and uses a delegate type named `Function`.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DelegateExample":::

<span data-ttu-id="23715-160">Экземпляр `Function` с типом делегата может ссылаться на любой метод, который принимает аргумент `double` и возвращает значение `double`.</span><span class="sxs-lookup"><span data-stu-id="23715-160">An instance of the `Function` delegate type can reference any method that takes a `double` argument and returns a `double` value.</span></span> <span data-ttu-id="23715-161">Метод `Apply` применяет заданный `Function` к элементам `double[]` и возвращает `double[]` с результатами.</span><span class="sxs-lookup"><span data-stu-id="23715-161">The `Apply` method applies a given `Function` to the elements of a `double[]`, returning a `double[]` with the results.</span></span> <span data-ttu-id="23715-162">В методе `Main` используется `Apply` для применения трех различных функций к `double[]`.</span><span class="sxs-lookup"><span data-stu-id="23715-162">In the `Main` method, `Apply` is used to apply three different functions to a `double[]`.</span></span>

<span data-ttu-id="23715-163">Делегат может ссылаться на статический метод (например, `Square` или `Math.Sin` в предыдущем примере) или метод экземпляра (например, `m.Multiply` в предыдущем примере).</span><span class="sxs-lookup"><span data-stu-id="23715-163">A delegate can reference either a static method (such as `Square` or `Math.Sin` in the previous example) or an instance method (such as `m.Multiply` in the previous example).</span></span> <span data-ttu-id="23715-164">Делегат, который ссылается на метод экземпляра, также содержит ссылку на конкретный объект. Когда метод экземпляра вызывается через делегат, этот объект превращается в `this` в вызове.</span><span class="sxs-lookup"><span data-stu-id="23715-164">A delegate that references an instance method also references a particular object, and when the instance method is invoked through the delegate, that object becomes `this` in the invocation.</span></span>

<span data-ttu-id="23715-165">Делегаты могут также создаваться с использованием анонимных функций, то есть создаваемых при объявлении "встроенных методов".</span><span class="sxs-lookup"><span data-stu-id="23715-165">Delegates can also be created using anonymous functions, which are "inline methods" that are created when declared.</span></span> <span data-ttu-id="23715-166">Анонимные функции могут использовать локальные переменные соседних методов.</span><span class="sxs-lookup"><span data-stu-id="23715-166">Anonymous functions can see the local variables of the surrounding methods.</span></span> <span data-ttu-id="23715-167">В следующем примере не создается класс:</span><span class="sxs-lookup"><span data-stu-id="23715-167">The following example doesn't create a class:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="UseDelegate":::

<span data-ttu-id="23715-168">Делегат не имеет информации или ограничений в отношении того, к какому классу относится метод, на который он ссылается.</span><span class="sxs-lookup"><span data-stu-id="23715-168">A delegate doesn't know or care about the class of the method it references.</span></span> <span data-ttu-id="23715-169">Достаточно лишь, чтобы метод, на который указывает ссылка, имел такие же параметры и тип возвращаемого значения, что и делегат.</span><span class="sxs-lookup"><span data-stu-id="23715-169">All that matters is that the referenced method has the same parameters and return type as the delegate.</span></span>

## <a name="async--await"></a><span data-ttu-id="23715-170">async и await</span><span class="sxs-lookup"><span data-stu-id="23715-170">async / await</span></span>

<span data-ttu-id="23715-171">C# поддерживает асинхронные программы с двумя ключевыми словами: `async` и `await`.</span><span class="sxs-lookup"><span data-stu-id="23715-171">C# supports asynchronous programs with two keywords: `async` and `await`.</span></span> <span data-ttu-id="23715-172">Чтобы объявить метод как асинхронный, нужно добавить модификатор `async` в его объявление.</span><span class="sxs-lookup"><span data-stu-id="23715-172">You add the `async` modifier to a method declaration to declare the method is asynchronous.</span></span> <span data-ttu-id="23715-173">Оператор `await` предписывает компилятору асинхронно ожидать результата для завершения выполнения.</span><span class="sxs-lookup"><span data-stu-id="23715-173">The `await` operator tells the compiler to asynchronously await for a result to finish.</span></span> <span data-ttu-id="23715-174">Управление возвращается вызывающему объекту, а метод возвращает структуру, которая управляет состоянием асинхронной работы.</span><span class="sxs-lookup"><span data-stu-id="23715-174">Control is returned to the caller, and the method returns a structure that manages the state of the asynchronous work.</span></span> <span data-ttu-id="23715-175">Обычно структурой является <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, но это также может быть любой тип, поддерживающий шаблон ожидания.</span><span class="sxs-lookup"><span data-stu-id="23715-175">The structure is typically a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, but can be any type that supports the awaiter pattern.</span></span> <span data-ttu-id="23715-176">Эти возможности позволяют писать код, который считывается как синхронный аналог, но выполняется асинхронно.</span><span class="sxs-lookup"><span data-stu-id="23715-176">These features enable you to write code that reads as its synchronous counterpart, but executes asynchronously.</span></span> <span data-ttu-id="23715-177">Например, следующий код скачивает домашнюю страницу [документации Майкрософт](/):</span><span class="sxs-lookup"><span data-stu-id="23715-177">For example, the following code downloads the home page for [Microsoft docs](/):</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="AsyncExample":::

<span data-ttu-id="23715-178">В этом небольшом примере показаны основные особенности асинхронного программирования:</span><span class="sxs-lookup"><span data-stu-id="23715-178">This small sample shows the major features for asynchronous programming:</span></span>

- <span data-ttu-id="23715-179">Объявление метода включает в себя модификатор `async`.</span><span class="sxs-lookup"><span data-stu-id="23715-179">The method declaration includes the `async` modifier.</span></span>
- <span data-ttu-id="23715-180">Тело метода (`await`) ожидает возврата управления методом `GetByteArrayAsync`.</span><span class="sxs-lookup"><span data-stu-id="23715-180">The body of the method `await`s the return of the `GetByteArrayAsync` method.</span></span>
- <span data-ttu-id="23715-181">Тип, указанный в операторе `return`, соответствует аргументу типа в объявлении `Task<T>` для метода.</span><span class="sxs-lookup"><span data-stu-id="23715-181">The type specified in the `return` statement matches the type argument in the `Task<T>` declaration for the method.</span></span> <span data-ttu-id="23715-182">(Метод, возвращающий `Task`, будет использовать операторы `return` без аргументов.)</span><span class="sxs-lookup"><span data-stu-id="23715-182">(A method that returns a `Task` would use `return` statements without any argument).</span></span>

## <a name="attributes"></a><span data-ttu-id="23715-183">Атрибуты</span><span class="sxs-lookup"><span data-stu-id="23715-183">Attributes</span></span>

<span data-ttu-id="23715-184">Типы, члены и другие сущности в программе C# поддерживают модификаторы, которые управляют некоторыми аспектами их поведения.</span><span class="sxs-lookup"><span data-stu-id="23715-184">Types, members, and other entities in a C# program support modifiers that control certain aspects of their behavior.</span></span> <span data-ttu-id="23715-185">Например, доступность метода определяется с помощью модификаторов `public`, `protected`, `internal` и `private`.</span><span class="sxs-lookup"><span data-stu-id="23715-185">For example, the accessibility of a method is controlled using the `public`, `protected`, `internal`, and `private` modifiers.</span></span> <span data-ttu-id="23715-186">C# обобщает эту возможность, позволяя пользователям определять собственные типы декларативных сведений, назначать их для сущностей программы и извлекать во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="23715-186">C# generalizes this capability such that user-defined types of declarative information can be attached to program entities and retrieved at run-time.</span></span> <span data-ttu-id="23715-187">В программах эти дополнительные декларативные сведения определяются и используются посредством [_ *_атрибутов_*\*](../programming-guide/concepts/attributes/index.md).</span><span class="sxs-lookup"><span data-stu-id="23715-187">Programs specify this additional declarative information by defining and using [_ *_attributes_*\*](../programming-guide/concepts/attributes/index.md).</span></span>

<span data-ttu-id="23715-188">Следующий пример кода объявляет атрибут `HelpAttribute`, который можно поместить в сущности программы для указания связей с соответствующей документацией.</span><span class="sxs-lookup"><span data-stu-id="23715-188">The following example declares a `HelpAttribute` attribute that can be placed on program entities to provide links to their associated documentation.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DefineAttribute":::

<span data-ttu-id="23715-189">Все классы атрибутов являются производными от базового класса <xref:System.Attribute>, который предоставляется в библиотеке .NET.</span><span class="sxs-lookup"><span data-stu-id="23715-189">All attribute classes derive from the <xref:System.Attribute> base class provided by the .NET library.</span></span> <span data-ttu-id="23715-190">Чтобы задать атрибут, его имя и возможные аргументы указываются в квадратных скобках непосредственно перед объявлением соответствующей сущности.</span><span class="sxs-lookup"><span data-stu-id="23715-190">Attributes can be applied by giving their name, along with any arguments, inside square brackets just before the associated declaration.</span></span> <span data-ttu-id="23715-191">Если имя атрибута заканчивается на `Attribute`, этот суффикс можно опускать при указании ссылки на этот атрибут.</span><span class="sxs-lookup"><span data-stu-id="23715-191">If an attribute’s name ends in `Attribute`, that part of the name can be omitted when the attribute is referenced.</span></span> <span data-ttu-id="23715-192">Например, атрибут с именем `HelpAttribute` можно использовать так:</span><span class="sxs-lookup"><span data-stu-id="23715-192">For example, the `HelpAttribute` can be used as follows.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="UseAttributes":::

<span data-ttu-id="23715-193">Этот пример кода присоединяет атрибут `HelpAttribute` к классу `Widget`.</span><span class="sxs-lookup"><span data-stu-id="23715-193">This example attaches a `HelpAttribute` to the `Widget` class.</span></span> <span data-ttu-id="23715-194">Также он добавляет другой атрибут `HelpAttribute` для метода `Display` в этом классе.</span><span class="sxs-lookup"><span data-stu-id="23715-194">It adds another `HelpAttribute` to the `Display` method in the class.</span></span> <span data-ttu-id="23715-195">Открытые конструкторы класса атрибута указывают, какие сведения необходимо указать при назначении атрибута некоторой сущности программы.</span><span class="sxs-lookup"><span data-stu-id="23715-195">The public constructors of an attribute class control the information that must be provided when the attribute is attached to a program entity.</span></span> <span data-ttu-id="23715-196">Дополнительные сведения можно предоставить через обращения к открытым свойствам класса атрибута, доступным для чтения и записи (например, как указанная выше ссылка на свойство `Topic`).</span><span class="sxs-lookup"><span data-stu-id="23715-196">Additional information can be provided by referencing public read-write properties of the attribute class (such as the reference to the `Topic` property previously).</span></span>

<span data-ttu-id="23715-197">Метаданные, определенные атрибутами, можно считывать и использовать во время выполнения с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="23715-197">The metadata defined by attributes can be read and manipulated at runtime using reflection.</span></span> <span data-ttu-id="23715-198">Когда с помощью этого метода выполняется запрос конкретного атрибута, вызывается конструктор для класса атрибута с указанием сведений, представленных в исходном коде программы,</span><span class="sxs-lookup"><span data-stu-id="23715-198">When a particular attribute is requested using this technique, the constructor for the attribute class is invoked with the information provided in the program source.</span></span> <span data-ttu-id="23715-199">а затем возвращается созданный экземпляр атрибута.</span><span class="sxs-lookup"><span data-stu-id="23715-199">The resulting attribute instance is returned.</span></span> <span data-ttu-id="23715-200">Если дополнительные сведения предоставляются через свойства, перед возвращением экземпляра атрибута этим свойствам присваиваются указанные значения.</span><span class="sxs-lookup"><span data-stu-id="23715-200">If additional information was provided through properties, those properties are set to the given values before the attribute instance is returned.</span></span>

<span data-ttu-id="23715-201">В следующем примере кода показано, как получить экземпляр класса `HelpAttribute`, связанный с классом `Widget` и его методом `Display`.</span><span class="sxs-lookup"><span data-stu-id="23715-201">The following code sample demonstrates how to get the `HelpAttribute` instances associated to the `Widget` class and its `Display` method.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ReadAttributes":::

## <a name="learn-more"></a><span data-ttu-id="23715-202">Дополнительные сведения</span><span class="sxs-lookup"><span data-stu-id="23715-202">Learn more</span></span>

<span data-ttu-id="23715-203">Узнать больше о C# можно с помощью наших [учебников](../tutorials/index.md).</span><span class="sxs-lookup"><span data-stu-id="23715-203">You can explore more about C# by trying one of our [tutorials](../tutorials/index.md).</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="23715-204">Назад</span><span class="sxs-lookup"><span data-stu-id="23715-204">Previous</span></span>](program-building-blocks.md)
